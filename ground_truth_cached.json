[
    {
        "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
        "vulnerabilityId": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 63,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 64,
                                "content": "      SqlInjectionLesson8.log(connection, queryInjection);"
                            },
                            {
                                "line": 65,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 66,
                                "content": "      // check new sum of salaries other employees and new salaries of John"
                            },
                            {
                                "line": 67,
                                "content": "      int newJohnSalary = this.getJohnSalary(connection);"
                            }
                        ],
                        "id": "9446c87c-6ab7-484f-ac37-96adab929966",
                        "vulnerableStartLine": 65,
                        "vulnerableEndLine": 65,
                        "startLine": 63,
                        "endLine": 67,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
                "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
                "createdAt": "2025-07-31T11:45:32.000Z",
                "updateAt": "2025-08-03T14:44:19.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "WebGoat-main/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "vulnerableStartLine": 65,
                "vulnerableEndLine": 65,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SOURCE",
                        "ligne": 44,
                        "explication": "Paramètres HTTP non validés reçus via @RequestParam",
                        "variables": "name, auth_tan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "PROPAGATION",
                        "ligne": 50,
                        "explication": "Concaténation directe des paramètres utilisateur dans la requête SQL",
                        "variables": "queryInjection"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SINK",
                        "ligne": 65,
                        "explication": "Exécution de la requête SQL non paramétrée contenant les données utilisateur",
                        "variables": "queryInjection"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif - Les paramètres HTTP name et auth_tan sont directement concaténés dans une requête SQL sans validation ni paramétrage, permettant une injection SQL. L'endpoint /SqlInjection/attack9 est accessible via POST et la vulnérabilité est exploitable."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 24,
                                "content": "    try (Connection connection = dataSource.getConnection()) {"
                            },
                            {
                                "line": 25,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 26,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 27,
                                "content": "      return \"Query executed successfully\";"
                            },
                            {
                                "line": 28,
                                "content": "    } catch (SQLException e) {"
                            }
                        ],
                        "id": "15d51eea-48b2-49d1-aa28-d8f6b5bda1b4",
                        "vulnerableStartLine": 26,
                        "vulnerableEndLine": 26,
                        "startLine": 24,
                        "endLine": 28,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T13:00:20.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "vulnerableStartLine": 26,
                "vulnerableEndLine": 26,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/AdvancedEmployeeQueryController.java",
                "category": "SOURCE",
                "ligne": 31,
                "explication": "Paramètres HTTP reçus via @RequestParam depuis l'endpoint /AdvancedQuery/searchEmployee",
                "variables": "employee_name, auth_token"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/SecurityFilterManager.java",
                "category": "VALIDATION",
                "ligne": 13,
                "explication": "Validation de sécurité basique effectuée par le SecurityFilterManager",
                "variables": "userLastName, userAuthCode"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeSearchService.java",
                "category": "SANITIZATION",
                "ligne": 15,
                "explication": "Application de la sanitisation via QueryValidationUtil.processUserInput qui nettoie les caractères dangereux",
                "variables": "processedName, processedAuth"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/QueryValidationUtil.java",
                "category": "SANITIZATION_LOGIC",
                "ligne": 13,
                "explication": "Nettoyage des caractères non alphanumériques via regex et remplacement des caractères dangereux",
                "variables": "cleaned"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "category": "SINK",
                "ligne": 25,
                "explication": "Exécution de la requête SQL avec les données préalablement sanitisées",
                "variables": "queryInjection"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne statement.execute(queryInjection) soit détectée comme vulnérable par le scanner, les données utilisateur passent par un processus de validation et sanitisation à travers QueryValidationUtil.processUserInput() qui supprime tous les caractères non alphanumériques via regex ^[a-zA-Z0-9_-]+$, rendant l'injection SQL impossible. Le dataflow montre que les variables sont nettoyées avant d'atteindre le sink."
        }
    }
]