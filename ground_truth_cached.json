[
    {
        "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
        "vulnerabilityId": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 63,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 64,
                                "content": "      SqlInjectionLesson8.log(connection, queryInjection);"
                            },
                            {
                                "line": 65,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 66,
                                "content": "      // check new sum of salaries other employees and new salaries of John"
                            },
                            {
                                "line": 67,
                                "content": "      int newJohnSalary = this.getJohnSalary(connection);"
                            }
                        ],
                        "id": "9446c87c-6ab7-484f-ac37-96adab929966",
                        "vulnerableStartLine": 65,
                        "vulnerableEndLine": 65,
                        "startLine": 63,
                        "endLine": 67,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
                "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
                "createdAt": "2025-07-31T11:45:32.000Z",
                "updateAt": "2025-08-03T14:44:19.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "WebGoat-main/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "vulnerableStartLine": 65,
                "vulnerableEndLine": 65,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SOURCE",
                        "ligne": 44,
                        "explication": "Paramètres HTTP non validés reçus via @RequestParam",
                        "variables": "name, auth_tan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "PROPAGATION",
                        "ligne": 50,
                        "explication": "Concaténation directe des paramètres utilisateur dans la requête SQL",
                        "variables": "queryInjection"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SINK",
                        "ligne": 65,
                        "explication": "Exécution de la requête SQL non paramétrée contenant les données utilisateur",
                        "variables": "queryInjection"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif - Les paramètres HTTP name et auth_tan sont directement concaténés dans une requête SQL sans validation ni paramétrage, permettant une injection SQL. L'endpoint /SqlInjection/attack9 est accessible via POST et la vulnérabilité est exploitable."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 24,
                                "content": "    try (Connection connection = dataSource.getConnection()) {"
                            },
                            {
                                "line": 25,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 26,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 27,
                                "content": "      return \"Query executed successfully\";"
                            },
                            {
                                "line": 28,
                                "content": "    } catch (SQLException e) {"
                            }
                        ],
                        "id": "15d51eea-48b2-49d1-aa28-d8f6b5bda1b4",
                        "vulnerableStartLine": 26,
                        "vulnerableEndLine": 26,
                        "startLine": 24,
                        "endLine": 28,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T13:00:20.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "vulnerableStartLine": 26,
                "vulnerableEndLine": 26,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/AdvancedEmployeeQueryController.java",
                "category": "SOURCE",
                "ligne": 31,
                "explication": "Paramètres HTTP reçus via @RequestParam depuis l'endpoint /AdvancedQuery/searchEmployee",
                "variables": "employee_name, auth_token"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/SecurityFilterManager.java",
                "category": "VALIDATION",
                "ligne": 13,
                "explication": "Validation de sécurité basique effectuée par le SecurityFilterManager",
                "variables": "userLastName, userAuthCode"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeSearchService.java",
                "category": "SANITIZATION",
                "ligne": 15,
                "explication": "Application de la sanitisation via QueryValidationUtil.processUserInput qui nettoie les caractères dangereux",
                "variables": "processedName, processedAuth"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/QueryValidationUtil.java",
                "category": "SANITIZATION_LOGIC",
                "ligne": 13,
                "explication": "Nettoyage des caractères non alphanumériques via regex et remplacement des caractères dangereux",
                "variables": "cleaned"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "category": "SINK",
                "ligne": 25,
                "explication": "Exécution de la requête SQL avec les données préalablement sanitisées",
                "variables": "queryInjection"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne statement.execute(queryInjection) soit détectée comme vulnérable par le scanner, les données utilisateur passent par un processus de validation et sanitisation à travers QueryValidationUtil.processUserInput() qui supprime tous les caractères non alphanumériques via regex ^[a-zA-Z0-9_-]+$, rendant l'injection SQL impossible. Le dataflow montre que les variables sont nettoyées avant d'atteindre le sink."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "00701fd8-aeb5-494d-96a9-eeb4944df33f",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 54,
                                "content": "            connection.createStatement("
                            },
                            {
                                "line": 55,
                                "content": "                ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);"
                            },
                            {
                                "line": 56,
                                "content": "        ResultSet results = statement.executeQuery(query);"
                            },
                            {
                                "line": 57,
                                "content": ""
                            },
                            {
                                "line": 58,
                                "content": "        if (results.getStatement() != null) {"
                            }
                        ],
                        "id": "db305954-dc6f-4f99-8294-d5fa370956a6",
                        "vulnerableStartLine": 56,
                        "vulnerableEndLine": 56,
                        "startLine": 54,
                        "endLine": 58,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "00701fd8-aeb5-494d-96a9-eeb4944df33f",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T13:00:20.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                "vulnerableStartLine": 56,
                "vulnerableEndLine": 56,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "f4e058bc-9f13-4208-887a-4adfc626913c",
                            "name": "OWASP Top 10 A03 2021 Injection",
                            "url": "https://owasp.org/Top10/A03_2021-Injection"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "jdbc-sqli.java",
                            "content": "package testcode.sqli;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class Jdbc {\n\n    Connection con;\n\n    public void query1(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(\"select * from Users where name = '\"+input+\"'\");\n    }\n\n    public void query2(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        String sql = \"select * from Users where name = '\" + input + \"'\";\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(sql);\n    }\n\n    public void query3(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(String.format(\"select * from Users where name = '%s'\",input));\n        // ok: jdbc-sqli\n        ResultSet rs2 = stmt.executeQuery(\"select * from Users where name = '123'\");\n    }\n\n    public void query4(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        String sql = \"select * from Users where name = '%s'\";\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(String.format(sql,input));\n    }\n\n    public void executeQuerySamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.executeQuery(sql);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n    public void executeUpdateSamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ok: jdbc-sqli\n        stmt.executeUpdate(\"select * from Users where name = '123'\");\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql);\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n\n    public void executeExecuteLargeUpdateSamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql);\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n    public void otherSamples(String sql) throws SQLException {\n        con.nativeSQL(sql);\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.addBatch(sql);\n        String sqlString = \"select * from Users where name = '123'\";\n        // ok: jdbc-sqli\n        stmt.addBatch(sqlString);\n    }\n\n}\n"
                        }
                    ],
                    "id": "75ee42d2-8674-4aff-abf8-ce64e9f0fcaa",
                    "name": "JDBC SQL Injection via Unparameterized Queries",
                    "shortDescription": "Dynamic concatenation or formatting of user input into SQL statements can lead to SQL injection in JDBC when using Statement.",
                    "description": "Applications that build SQL queries by concatenating or formatting strings with user input allow **SQL injection**. In the provided code example, each `executeQuery` call uses `Statement` to run a query constructed via string concatenation or `String.format`, embedding the `input` parameter directly. Attackers can supply specially crafted input to alter the query logic, leading to unauthorized data access, data modification, or execution of arbitrary SQL commands.\r\n\r\n**Vulnerability Mechanism**:\r\n- Use of `Statement` instead of parameterized queries\r\n- Direct embedding of untrusted values in SQL strings via `+` or `String.format`\r\n\r\n**Potential Impact**:\r\n- **Data Confidentiality Loss**: exposure of sensitive records\r\n- **Data Integrity Violation**: unauthorized INSERT, UPDATE, or DELETE operations\r\n- **System Availability Impact**: execution of destructive SQL like `DROP` or `TRUNCATE`",
                    "howToPrevent": "To remediate this vulnerability, replace dynamic SQL construction with parameterized queries using `PreparedStatement`:\r\n\r\n1. Define the SQL with `?` placeholders:\r\n   ```java\r\n   String sql = \"SELECT * FROM Users WHERE name = ?\";\r\n   ```\r\n2. Obtain a `PreparedStatement` from the `Connection`:\r\n   ```java\r\n   PreparedStatement ps = con.prepareStatement(sql);\r\n   ```\r\n3. Bind each user-supplied value using the appropriate setter before execution:\r\n   ```java\r\n   ps.setString(1, input);\r\n   ```\r\n4. Execute the query and handle results:\r\n   ```java\r\n   ResultSet rs = ps.executeQuery();\r\n   ```\r\n\r\nSecure coding practices:\r\n- Never concatenate or format untrusted input into SQL strings\r\n- Always use parameter binding methods (`setString`, `setInt`, etc.)\r\n- Close statements and result sets in `try-with-resources` blocks",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "9.8"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "jdbc"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "HIGH",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/container/WebGoat.java",
                        "category": "BOOTSTRAP",
                        "ligne": 22,
                        "explication": "Application Spring Boot avec @ComponentScan incluant le package org.owasp.webgoat.lessons",
                        "variables": "ComponentScan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "ENDPOINT_REGISTRATION",
                        "ligne": 33,
                        "explication": "Classe annotée @RestController implémentant AssignmentEndpoint, automatiquement détectée par Spring",
                        "variables": "SqlInjectionLesson10"
                    },
                    {
                        "file": "src/main/resources/lessons/sqlinjection/html/SqlInjection.html",
                        "category": "UI_ACCESS",
                        "ligne": 276,
                        "explication": "Interface utilisateur HTML avec formulaire pointant vers l'endpoint /SqlInjection/attack10",
                        "variables": "th:action"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "SOURCE",
                        "ligne": 44,
                        "explication": "Paramètre HTTP action_string reçu via @RequestParam sans validation",
                        "variables": "action_string"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "PROPAGATION",
                        "ligne": 45,
                        "explication": "Passage du paramètre à la méthode injectableQueryAvailability",
                        "variables": "action"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "PROPAGATION",
                        "ligne": 49,
                        "explication": "Concaténation directe du paramètre utilisateur dans la requête SQL",
                        "variables": "query"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "SINK",
                        "ligne": 56,
                        "explication": "Exécution de la requête SQL non paramétrée contenant les données utilisateur",
                        "variables": "query"
                    },
                    {
                        "file": "src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10Test.java",
                        "category": "EXPLOITATION_PROOF",
                        "ligne": 43,
                        "explication": "Test unitaire démontrant l'exploitation avec payload DROP TABLE",
                        "variables": "%'; DROP TABLE access_log;--"
                    },
                    {
                        "file": "src/it/java/org/owasp/webgoat/integration/SqlInjectionLessonIntegrationTest.java",
                        "category": "INTEGRATION_PROOF",
                        "ligne": 32,
                        "explication": "Test d'intégration avec payload SQL injection réel",
                        "variables": "%update% '; drop table access_log ; --'"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif confirmé - Le paramètre HTTP action_string est directement concaténé dans une requête SQL LIKE sans validation. L'endpoint /SqlInjection/attack10 est pleinement intégré dans l'application WebGoat : (1) Enregistré automatiquement via @ComponentScan, (2) Accessible via interface HTML, (3) Testé avec des payloads SQL injection réels dans les tests unitaires et d'intégration, (4) Pas de code mort - la vulnérabilité est exploitable en production."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "f11cbed6-7174-4741-bb5b-cc4ddc503238",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 23,
                                "content": "      Statement statement = connection.createStatement("
                            },
                            {
                                "line": 24,
                                "content": "          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);"
                            },
                            {
                                "line": 25,
                                "content": "      ResultSet results = statement.executeQuery(query);"
                            },
                            {
                                "line": 26,
                                "content": "      "
                            },
                            {
                                "line": 27,
                                "content": "      if (results.next()) {"
                            }
                        ],
                        "id": "0e35a9d6-f785-4d5f-a5ed-e708052703db",
                        "vulnerableStartLine": 25,
                        "vulnerableEndLine": 25,
                        "startLine": 23,
                        "endLine": 27,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "f11cbed6-7174-4741-bb5b-cc4ddc503238",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:13:32.000Z",
                "updateAt": "2025-08-03T13:13:32.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/analytics/service/LogDataRepository.java",
                "vulnerableStartLine": 25,
                "vulnerableEndLine": 25,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/controller/LogAnalyticsController.java",
                "category": "SOURCE",
                "ligne": 30,
                "explication": "Paramètre HTTP log_search_term reçu via @RequestParam depuis l'endpoint /Analytics/searchLogs",
                "variables": "log_search_term"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/manager/SecurityAnalyticsManager.java",
                "category": "VALIDATION",
                "ligne": 15,
                "explication": "Validation de sécurité basique effectuée par le SecurityAnalyticsManager",
                "variables": "userInput"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/service/LogAnalyticsService.java",
                "category": "SANITIZATION",
                "ligne": 15,
                "explication": "Application de la sanitisation via DataFilterUtil.cleanLogData qui nettoie les caractères dangereux",
                "variables": "filteredTerm"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/validation/DataFilterUtil.java",
                "category": "SANITIZATION_LOGIC",
                "ligne": 13,
                "explication": "Nettoyage des caractères non alphanumériques via regex et remplacement des caractères SQL dangereux",
                "variables": "trimmed"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/service/LogDataRepository.java",
                "category": "SINK",
                "ligne": 24,
                "explication": "Exécution de la requête SQL avec les données préalablement sanitisées",
                "variables": "query"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne statement.executeQuery(query) soit détectée comme vulnérable par le scanner, les données utilisateur passent par un processus de validation et sanitisation à travers DataFilterUtil.cleanLogData() qui supprime tous les caractères non alphanumériques via regex ^[a-zA-Z0-9_\\-\\s]+$, éliminant les caractères SQL dangereux comme les quotes. Le dataflow montre que les variables sont nettoyées avant d'atteindre le sink."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "11838c3f-de39-41fc-b67f-981c57cf067b",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 112,
                                "content": "              .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD)"
                            },
                            {
                                "line": 113,
                                "content": "              .compact();"
                            },
                            {
                                "line": 114,
                                "content": "      Cookie cookie = new Cookie(\"access_token\", token);"
                            },
                            {
                                "line": 115,
                                "content": "      response.addCookie(cookie);"
                            },
                            {
                                "line": 116,
                                "content": "      response.setStatus(HttpStatus.OK.value());"
                            }
                        ],
                        "id": "cc0f423c-3482-43b3-a917-6097481e01f2",
                        "vulnerableStartLine": 114,
                        "vulnerableEndLine": 114,
                        "startLine": 112,
                        "endLine": 116,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "11838c3f-de39-41fc-b67f-981c57cf067b",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T15:13:37.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                "vulnerableStartLine": 114,
                "vulnerableEndLine": 114,
                "vulnerability": {
                    "cwe": [
                        "CWE-319"
                    ],
                    "owaspTop10": [
                        "A03:2017 - Sensitive Data Exposure",
                        "A02:2021 - Cryptographic Failures"
                    ],
                    "cweArray": [
                        "CWE-319"
                    ],
                    "references": [
                        {
                            "id": "0c163946-05c4-4593-ae1f-68f151885676",
                            "name": "Java Servlet Cookie.setSecure(boolean) API Documentation",
                            "url": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)"
                        },
                        {
                            "id": "620f515c-24df-4432-adc1-5307053d20fe",
                            "name": "OWASP Secure Cookie Attribute",
                            "url": "https://owasp.org/www-community/controls/SecureCookieAttribute"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "cookie-issecure-false.java",
                            "content": "public class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-issecure-false\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}\n"
                        }
                    ],
                    "id": "a216e0f1-7458-4388-a1c8-edbe7bd776af",
                    "name": "Insecure Cookie Without Secure Flag",
                    "shortDescription": "Cookie created without the Secure attribute may be sent over HTTP, exposing session data to network attackers.",
                    "description": "A session cookie is instantiated without setting its **Secure** attribute. Without this flag, browsers will transmit the cookie over unencrypted HTTP connections. An attacker positioned on the network path can intercept or steal the cookie, leading to session hijacking and unauthorized account access. The flaw originates from using default cookie settings (`new Cookie(name, value)`) without invoking `cookie.setSecure(true)`. Key risks include:\r\n\r\n- **Session Exposure:** Attackers can read session identifiers in transit.\r\n- **Account Takeover:** Stolen cookies allow impersonation of legitimate users.\r\n- **Cross-Site Scripting Amplification:** Exploit of existing scripting flaws becomes easier if cookies lack transport protection.",
                    "howToPrevent": "1. Always set the **Secure** attribute on cookies carrying sensitive data:\r\n   ```java\r\n   Cookie cookie = new Cookie(\"name\", \"value\");\r\n   cookie.setSecure(true);\r\n   ```\r\n2. Enforce HTTPS across the entire application. Redirect all HTTP requests to HTTPS.\r\n3. Use **HttpOnly** and **SameSite** flags in combination to limit client-side script access and cross-site requests:\r\n   ```java\r\n   cookie.setHttpOnly(true);\r\n   cookie.setSecure(true);\r\n   cookie.setPath(\"/\");\r\n   cookie.setMaxAge(durationInSeconds);\r\n   response.addCookie(cookie);\r\n   ```\r\n4. Configure web framework or server to apply secure cookie defaults globally rather than per-instance.",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
                        "baseScore": "8.6"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "java",
                            "cookie"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "LOW",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/container/WebGoat.java",
                        "category": "BOOTSTRAP",
                        "ligne": 22,
                        "explication": "Application Spring Boot avec @ComponentScan incluant le package org.owasp.webgoat.lessons",
                        "variables": "ComponentScan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "ENDPOINT_REGISTRATION",
                        "ligne": 53,
                        "explication": "Classe annotée @RestController implémentant AssignmentEndpoint, automatiquement détectée par Spring",
                        "variables": "JWTVotesEndpoint"
                    },
                    {
                        "file": "src/main/resources/lessons/jwt/js/jwt-voting.js",
                        "category": "UI_ACCESS",
                        "ligne": 7,
                        "explication": "Interface JavaScript appelant l'endpoint via AJAX JWT/votings/login avec paramètre user",
                        "variables": "user"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "SOURCE",
                        "ligne": 104,
                        "explication": "Paramètre HTTP user reçu via @RequestParam dans la méthode login",
                        "variables": "user"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "TOKEN_GENERATION",
                        "ligne": 109,
                        "explication": "Génération d'un JWT token contenant des données utilisateur sensibles",
                        "variables": "token"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "SINK",
                        "ligne": 114,
                        "explication": "Création d'un cookie contenant le JWT sans flag Secure, transmissible sur HTTP",
                        "variables": "cookie"
                    },
                    {
                        "file": "src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java",
                        "category": "EXPLOITATION_PROOF",
                        "ligne": 99,
                        "explication": "Test unitaire vérifiant la création du cookie avec contenu sensible",
                        "variables": "access_token"
                    },
                    {
                        "file": "src/it/java/org/owasp/webgoat/integration/JWTLessonIntegrationTest.java",
                        "category": "INTEGRATION_PROOF",
                        "ligne": 136,
                        "explication": "Test d'intégration récupérant le cookie access_token depuis l'endpoint",
                        "variables": "access_token"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif confirmé - Le cookie access_token contenant un JWT avec des données sensibles (admin, user) est créé sans flag Secure à la ligne 114. L'endpoint /JWT/votings/login est pleinement intégré : (1) Accessible via interface JavaScript, (2) Testé dans les tests unitaires et d'intégration, (3) Cookie transmissible sur HTTP permettant l'interception du JWT par un attaquant réseau. Pas de code mort - la vulnérabilité est exploitable en production."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "9a38a5aa-1366-4828-85e1-6ccfd450cf89",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 23,
                                "content": "    "
                            },
                            {
                                "line": 24,
                                "content": "    if (tokenManager.validateTokenFormat(processedToken)) {"
                            },
                            {
                                "line": 25,
                                "content": "      Cookie cookie = new Cookie(\"access_token\", userToken);"
                            },
                            {
                                "line": 26,
                                "content": "      cookieService.applyCookieDefaults(cookie);"
                            },
                            {
                                "line": 27,
                                "content": "      response.addCookie(cookie);"
                            }
                        ],
                        "id": "074b27c0-d263-4f31-92ea-5330d9c039c8",
                        "vulnerableStartLine": 25,
                        "vulnerableEndLine": 25,
                        "startLine": 23,
                        "endLine": 27,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "9a38a5aa-1366-4828-85e1-6ccfd450cf89",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:31:41.000Z",
                "updateAt": "2025-08-03T13:31:41.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/security/session/SessionManagementService.java",
                "vulnerableStartLine": 25,
                "vulnerableEndLine": 25,
                "vulnerability": {
                    "cwe": [
                        "CWE-319"
                    ],
                    "owaspTop10": [
                        "A03:2017 - Sensitive Data Exposure",
                        "A02:2021 - Cryptographic Failures"
                    ],
                    "cweArray": [
                        "CWE-319"
                    ],
                    "references": [
                        {
                            "id": "0c163946-05c4-4593-ae1f-68f151885676",
                            "name": "Java Servlet Cookie.setSecure(boolean) API Documentation",
                            "url": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)"
                        },
                        {
                            "id": "620f515c-24df-4432-adc1-5307053d20fe",
                            "name": "OWASP Secure Cookie Attribute",
                            "url": "https://owasp.org/www-community/controls/SecureCookieAttribute"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "cookie-issecure-false.java",
                            "content": "public class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-issecure-false\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}\n"
                        }
                    ],
                    "id": "a216e0f1-7458-4388-a1c8-edbe7bd776af",
                    "name": "Insecure Cookie Without Secure Flag",
                    "shortDescription": "Cookie created without the Secure attribute may be sent over HTTP, exposing session data to network attackers.",
                    "description": "A session cookie is instantiated without setting its **Secure** attribute. Without this flag, browsers will transmit the cookie over unencrypted HTTP connections. An attacker positioned on the network path can intercept or steal the cookie, leading to session hijacking and unauthorized account access. The flaw originates from using default cookie settings (`new Cookie(name, value)`) without invoking `cookie.setSecure(true)`. Key risks include:\r\n\r\n- **Session Exposure:** Attackers can read session identifiers in transit.\r\n- **Account Takeover:** Stolen cookies allow impersonation of legitimate users.\r\n- **Cross-Site Scripting Amplification:** Exploit of existing scripting flaws becomes easier if cookies lack transport protection.",
                    "howToPrevent": "1. Always set the **Secure** attribute on cookies carrying sensitive data:\r\n   ```java\r\n   Cookie cookie = new Cookie(\"name\", \"value\");\r\n   cookie.setSecure(true);\r\n   ```\r\n2. Enforce HTTPS across the entire application. Redirect all HTTP requests to HTTPS.\r\n3. Use **HttpOnly** and **SameSite** flags in combination to limit client-side script access and cross-site requests:\r\n   ```java\r\n   cookie.setHttpOnly(true);\r\n   cookie.setSecure(true);\r\n   cookie.setPath(\"/\");\r\n   cookie.setMaxAge(durationInSeconds);\r\n   response.addCookie(cookie);\r\n   ```\r\n4. Configure web framework or server to apply secure cookie defaults globally rather than per-instance.",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
                        "baseScore": "8.6"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "java",
                            "cookie"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "LOW",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "SOURCE",
                "ligne": 41,
                "explication": "Paramètre HTTP username reçu via @RequestParam depuis l'endpoint /SecureAuth/authenticate",
                "variables": "username"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "TOKEN_GENERATION",
                "ligne": 47,
                "explication": "Génération d'un JWT token avec données utilisateur sensibles",
                "variables": "token"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/session/SessionManagementService.java",
                "category": "SECURITY_LAYER",
                "ligne": 22,
                "explication": "Création du cookie via CookieSecurityService avec application de sécurité automatique",
                "variables": "cookie"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/service/CookieSecurityService.java",
                "category": "SECURITY_APPLICATION",
                "ligne": 24,
                "explication": "Application automatique du flag Secure basé sur la configuration de sécurité",
                "variables": "cookie"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/config/SecurityConfiguration.java",
                "category": "SECURITY_CONFIG",
                "ligne": 15,
                "explication": "Configuration de sécurité activant shouldSecureCookies() via security.cookie.secure=true",
                "variables": "cookieSecureDefault"
            },
            {
                "file": "src/main/resources/application-webgoat.properties",
                "category": "CONFIG_SOURCE",
                "ligne": 12,
                "explication": "Propriété de configuration security.cookie.secure=true activant la sécurisation automatique",
                "variables": "security.cookie.secure"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "SINK",
                "ligne": 51,
                "explication": "Cookie créé sans appel explicite setSecure() mais sécurisé par le service automatique",
                "variables": "cookie"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne Cookie cookie = new Cookie('access_token', token) soit détectée comme vulnérable par le scanner, le cookie est automatiquement sécurisé par le CookieSecurityService. Le dataflow montre que applyCookieDefaults() est appelé dans SessionManagementService, qui applique setSecure(true) basé sur la configuration security.cookie.secure=true. La vulnérabilité apparente est neutralisée par cette couche de sécurité automatique."
        }
    }
]