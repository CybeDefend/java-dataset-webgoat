[
    {
        "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
        "vulnerabilityId": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 63,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 64,
                                "content": "      SqlInjectionLesson8.log(connection, queryInjection);"
                            },
                            {
                                "line": 65,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 66,
                                "content": "      // check new sum of salaries other employees and new salaries of John"
                            },
                            {
                                "line": 67,
                                "content": "      int newJohnSalary = this.getJohnSalary(connection);"
                            }
                        ],
                        "id": "9446c87c-6ab7-484f-ac37-96adab929966",
                        "vulnerableStartLine": 65,
                        "vulnerableEndLine": 65,
                        "startLine": 63,
                        "endLine": 67,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
                "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
                "createdAt": "2025-07-31T11:45:32.000Z",
                "updateAt": "2025-08-03T14:44:19.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "WebGoat-main/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "vulnerableStartLine": 65,
                "vulnerableEndLine": 65,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SOURCE",
                        "ligne": 44,
                        "explication": "Paramètres HTTP non validés reçus via @RequestParam",
                        "variables": "name, auth_tan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "PROPAGATION",
                        "ligne": 50,
                        "explication": "Concaténation directe des paramètres utilisateur dans la requête SQL",
                        "variables": "queryInjection"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                        "category": "SINK",
                        "ligne": 65,
                        "explication": "Exécution de la requête SQL non paramétrée contenant les données utilisateur",
                        "variables": "queryInjection"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif - Les paramètres HTTP name et auth_tan sont directement concaténés dans une requête SQL sans validation ni paramétrage, permettant une injection SQL. L'endpoint /SqlInjection/attack9 est accessible via POST et la vulnérabilité est exploitable."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 24,
                                "content": "    try (Connection connection = dataSource.getConnection()) {"
                            },
                            {
                                "line": 25,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 26,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 27,
                                "content": "      return \"Query executed successfully\";"
                            },
                            {
                                "line": 28,
                                "content": "    } catch (SQLException e) {"
                            }
                        ],
                        "id": "15d51eea-48b2-49d1-aa28-d8f6b5bda1b4",
                        "vulnerableStartLine": 26,
                        "vulnerableEndLine": 26,
                        "startLine": 24,
                        "endLine": 28,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "48939382-0e5a-4b1d-8ea2-8144c0a69fb2",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T13:00:20.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "vulnerableStartLine": 26,
                "vulnerableEndLine": 26,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/AdvancedEmployeeQueryController.java",
                "category": "SOURCE",
                "ligne": 31,
                "explication": "Paramètres HTTP reçus via @RequestParam depuis l'endpoint /AdvancedQuery/searchEmployee",
                "variables": "employee_name, auth_token"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/SecurityFilterManager.java",
                "category": "VALIDATION",
                "ligne": 13,
                "explication": "Validation de sécurité basique effectuée par le SecurityFilterManager",
                "variables": "userLastName, userAuthCode"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeSearchService.java",
                "category": "SANITIZATION",
                "ligne": 15,
                "explication": "Application de la sanitisation via QueryValidationUtil.processUserInput qui nettoie les caractères dangereux",
                "variables": "processedName, processedAuth"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/QueryValidationUtil.java",
                "category": "SANITIZATION_LOGIC",
                "ligne": 13,
                "explication": "Nettoyage des caractères non alphanumériques via regex et remplacement des caractères dangereux",
                "variables": "cleaned"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/advanced/query/EmployeeRepository.java",
                "category": "SINK",
                "ligne": 25,
                "explication": "Exécution de la requête SQL avec les données préalablement sanitisées",
                "variables": "queryInjection"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne statement.execute(queryInjection) soit détectée comme vulnérable par le scanner, les données utilisateur passent par un processus de validation et sanitisation à travers QueryValidationUtil.processUserInput() qui supprime tous les caractères non alphanumériques via regex ^[a-zA-Z0-9_-]+$, rendant l'injection SQL impossible. Le dataflow montre que les variables sont nettoyées avant d'atteindre le sink."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "00701fd8-aeb5-494d-96a9-eeb4944df33f",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 54,
                                "content": "            connection.createStatement("
                            },
                            {
                                "line": 55,
                                "content": "                ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);"
                            },
                            {
                                "line": 56,
                                "content": "        ResultSet results = statement.executeQuery(query);"
                            },
                            {
                                "line": 57,
                                "content": ""
                            },
                            {
                                "line": 58,
                                "content": "        if (results.getStatement() != null) {"
                            }
                        ],
                        "id": "db305954-dc6f-4f99-8294-d5fa370956a6",
                        "vulnerableStartLine": 56,
                        "vulnerableEndLine": 56,
                        "startLine": 54,
                        "endLine": 58,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "00701fd8-aeb5-494d-96a9-eeb4944df33f",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T13:00:20.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                "vulnerableStartLine": 56,
                "vulnerableEndLine": 56,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "f4e058bc-9f13-4208-887a-4adfc626913c",
                            "name": "OWASP Top 10 A03 2021 Injection",
                            "url": "https://owasp.org/Top10/A03_2021-Injection"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "jdbc-sqli.java",
                            "content": "package testcode.sqli;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class Jdbc {\n\n    Connection con;\n\n    public void query1(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(\"select * from Users where name = '\"+input+\"'\");\n    }\n\n    public void query2(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        String sql = \"select * from Users where name = '\" + input + \"'\";\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(sql);\n    }\n\n    public void query3(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(String.format(\"select * from Users where name = '%s'\",input));\n        // ok: jdbc-sqli\n        ResultSet rs2 = stmt.executeQuery(\"select * from Users where name = '123'\");\n    }\n\n    public void query4(String input) throws SQLException {\n        Statement stmt = con.createStatement();\n        String sql = \"select * from Users where name = '%s'\";\n        // ruleid: jdbc-sqli\n        ResultSet rs = stmt.executeQuery(String.format(sql,input));\n    }\n\n    public void executeQuerySamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.executeQuery(sql);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.execute(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n    public void executeUpdateSamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ok: jdbc-sqli\n        stmt.executeUpdate(\"select * from Users where name = '123'\");\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql);\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.executeUpdate(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n\n    public void executeExecuteLargeUpdateSamples(String sql) throws SQLException {\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql);\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, new int[]{1, 2, 3});\n        // ruleid: jdbc-sqli\n        stmt.executeLargeUpdate(sql, new String[]{\"firstname\", \"middlename\", \"lastname\"});\n    }\n\n    public void otherSamples(String sql) throws SQLException {\n        con.nativeSQL(sql);\n        Statement stmt = con.createStatement();\n        // ruleid: jdbc-sqli\n        stmt.addBatch(sql);\n        String sqlString = \"select * from Users where name = '123'\";\n        // ok: jdbc-sqli\n        stmt.addBatch(sqlString);\n    }\n\n}\n"
                        }
                    ],
                    "id": "75ee42d2-8674-4aff-abf8-ce64e9f0fcaa",
                    "name": "JDBC SQL Injection via Unparameterized Queries",
                    "shortDescription": "Dynamic concatenation or formatting of user input into SQL statements can lead to SQL injection in JDBC when using Statement.",
                    "description": "Applications that build SQL queries by concatenating or formatting strings with user input allow **SQL injection**. In the provided code example, each `executeQuery` call uses `Statement` to run a query constructed via string concatenation or `String.format`, embedding the `input` parameter directly. Attackers can supply specially crafted input to alter the query logic, leading to unauthorized data access, data modification, or execution of arbitrary SQL commands.\r\n\r\n**Vulnerability Mechanism**:\r\n- Use of `Statement` instead of parameterized queries\r\n- Direct embedding of untrusted values in SQL strings via `+` or `String.format`\r\n\r\n**Potential Impact**:\r\n- **Data Confidentiality Loss**: exposure of sensitive records\r\n- **Data Integrity Violation**: unauthorized INSERT, UPDATE, or DELETE operations\r\n- **System Availability Impact**: execution of destructive SQL like `DROP` or `TRUNCATE`",
                    "howToPrevent": "To remediate this vulnerability, replace dynamic SQL construction with parameterized queries using `PreparedStatement`:\r\n\r\n1. Define the SQL with `?` placeholders:\r\n   ```java\r\n   String sql = \"SELECT * FROM Users WHERE name = ?\";\r\n   ```\r\n2. Obtain a `PreparedStatement` from the `Connection`:\r\n   ```java\r\n   PreparedStatement ps = con.prepareStatement(sql);\r\n   ```\r\n3. Bind each user-supplied value using the appropriate setter before execution:\r\n   ```java\r\n   ps.setString(1, input);\r\n   ```\r\n4. Execute the query and handle results:\r\n   ```java\r\n   ResultSet rs = ps.executeQuery();\r\n   ```\r\n\r\nSecure coding practices:\r\n- Never concatenate or format untrusted input into SQL strings\r\n- Always use parameter binding methods (`setString`, `setInt`, etc.)\r\n- Close statements and result sets in `try-with-resources` blocks",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "9.8"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "jdbc"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "HIGH",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/container/WebGoat.java",
                        "category": "BOOTSTRAP",
                        "ligne": 22,
                        "explication": "Application Spring Boot avec @ComponentScan incluant le package org.owasp.webgoat.lessons",
                        "variables": "ComponentScan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "ENDPOINT_REGISTRATION",
                        "ligne": 33,
                        "explication": "Classe annotée @RestController implémentant AssignmentEndpoint, automatiquement détectée par Spring",
                        "variables": "SqlInjectionLesson10"
                    },
                    {
                        "file": "src/main/resources/lessons/sqlinjection/html/SqlInjection.html",
                        "category": "UI_ACCESS",
                        "ligne": 276,
                        "explication": "Interface utilisateur HTML avec formulaire pointant vers l'endpoint /SqlInjection/attack10",
                        "variables": "th:action"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "SOURCE",
                        "ligne": 44,
                        "explication": "Paramètre HTTP action_string reçu via @RequestParam sans validation",
                        "variables": "action_string"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "PROPAGATION",
                        "ligne": 45,
                        "explication": "Passage du paramètre à la méthode injectableQueryAvailability",
                        "variables": "action"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "PROPAGATION",
                        "ligne": 49,
                        "explication": "Concaténation directe du paramètre utilisateur dans la requête SQL",
                        "variables": "query"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java",
                        "category": "SINK",
                        "ligne": 56,
                        "explication": "Exécution de la requête SQL non paramétrée contenant les données utilisateur",
                        "variables": "query"
                    },
                    {
                        "file": "src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10Test.java",
                        "category": "EXPLOITATION_PROOF",
                        "ligne": 43,
                        "explication": "Test unitaire démontrant l'exploitation avec payload DROP TABLE",
                        "variables": "%'; DROP TABLE access_log;--"
                    },
                    {
                        "file": "src/it/java/org/owasp/webgoat/integration/SqlInjectionLessonIntegrationTest.java",
                        "category": "INTEGRATION_PROOF",
                        "ligne": 32,
                        "explication": "Test d'intégration avec payload SQL injection réel",
                        "variables": "%update% '; drop table access_log ; --'"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif confirmé - Le paramètre HTTP action_string est directement concaténé dans une requête SQL LIKE sans validation. L'endpoint /SqlInjection/attack10 est pleinement intégré dans l'application WebGoat : (1) Enregistré automatiquement via @ComponentScan, (2) Accessible via interface HTML, (3) Testé avec des payloads SQL injection réels dans les tests unitaires et d'intégration, (4) Pas de code mort - la vulnérabilité est exploitable en production."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "f11cbed6-7174-4741-bb5b-cc4ddc503238",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 23,
                                "content": "      Statement statement = connection.createStatement("
                            },
                            {
                                "line": 24,
                                "content": "          ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);"
                            },
                            {
                                "line": 25,
                                "content": "      ResultSet results = statement.executeQuery(query);"
                            },
                            {
                                "line": 26,
                                "content": "      "
                            },
                            {
                                "line": 27,
                                "content": "      if (results.next()) {"
                            }
                        ],
                        "id": "0e35a9d6-f785-4d5f-a5ed-e708052703db",
                        "vulnerableStartLine": 25,
                        "vulnerableEndLine": 25,
                        "startLine": 23,
                        "endLine": 27,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "f11cbed6-7174-4741-bb5b-cc4ddc503238",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:13:32.000Z",
                "updateAt": "2025-08-03T13:13:32.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/analytics/service/LogDataRepository.java",
                "vulnerableStartLine": 25,
                "vulnerableEndLine": 25,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/controller/LogAnalyticsController.java",
                "category": "SOURCE",
                "ligne": 30,
                "explication": "Paramètre HTTP log_search_term reçu via @RequestParam depuis l'endpoint /Analytics/searchLogs",
                "variables": "log_search_term"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/manager/SecurityAnalyticsManager.java",
                "category": "VALIDATION",
                "ligne": 15,
                "explication": "Validation de sécurité basique effectuée par le SecurityAnalyticsManager",
                "variables": "userInput"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/service/LogAnalyticsService.java",
                "category": "SANITIZATION",
                "ligne": 15,
                "explication": "Application de la sanitisation via DataFilterUtil.cleanLogData qui nettoie les caractères dangereux",
                "variables": "filteredTerm"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/validation/DataFilterUtil.java",
                "category": "SANITIZATION_LOGIC",
                "ligne": 13,
                "explication": "Nettoyage des caractères non alphanumériques via regex et remplacement des caractères SQL dangereux",
                "variables": "trimmed"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/analytics/service/LogDataRepository.java",
                "category": "SINK",
                "ligne": 24,
                "explication": "Exécution de la requête SQL avec les données préalablement sanitisées",
                "variables": "query"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne statement.executeQuery(query) soit détectée comme vulnérable par le scanner, les données utilisateur passent par un processus de validation et sanitisation à travers DataFilterUtil.cleanLogData() qui supprime tous les caractères non alphanumériques via regex ^[a-zA-Z0-9_\\-\\s]+$, éliminant les caractères SQL dangereux comme les quotes. Le dataflow montre que les variables sont nettoyées avant d'atteindre le sink."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "11838c3f-de39-41fc-b67f-981c57cf067b",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 112,
                                "content": "              .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD)"
                            },
                            {
                                "line": 113,
                                "content": "              .compact();"
                            },
                            {
                                "line": 114,
                                "content": "      Cookie cookie = new Cookie(\"access_token\", token);"
                            },
                            {
                                "line": 115,
                                "content": "      response.addCookie(cookie);"
                            },
                            {
                                "line": 116,
                                "content": "      response.setStatus(HttpStatus.OK.value());"
                            }
                        ],
                        "id": "cc0f423c-3482-43b3-a917-6097481e01f2",
                        "vulnerableStartLine": 114,
                        "vulnerableEndLine": 114,
                        "startLine": 112,
                        "endLine": 116,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "11838c3f-de39-41fc-b67f-981c57cf067b",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T15:13:37.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                "vulnerableStartLine": 114,
                "vulnerableEndLine": 114,
                "vulnerability": {
                    "cwe": [
                        "CWE-319"
                    ],
                    "owaspTop10": [
                        "A03:2017 - Sensitive Data Exposure",
                        "A02:2021 - Cryptographic Failures"
                    ],
                    "cweArray": [
                        "CWE-319"
                    ],
                    "references": [
                        {
                            "id": "0c163946-05c4-4593-ae1f-68f151885676",
                            "name": "Java Servlet Cookie.setSecure(boolean) API Documentation",
                            "url": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)"
                        },
                        {
                            "id": "620f515c-24df-4432-adc1-5307053d20fe",
                            "name": "OWASP Secure Cookie Attribute",
                            "url": "https://owasp.org/www-community/controls/SecureCookieAttribute"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "cookie-issecure-false.java",
                            "content": "public class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-issecure-false\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}\n"
                        }
                    ],
                    "id": "a216e0f1-7458-4388-a1c8-edbe7bd776af",
                    "name": "Insecure Cookie Without Secure Flag",
                    "shortDescription": "Cookie created without the Secure attribute may be sent over HTTP, exposing session data to network attackers.",
                    "description": "A session cookie is instantiated without setting its **Secure** attribute. Without this flag, browsers will transmit the cookie over unencrypted HTTP connections. An attacker positioned on the network path can intercept or steal the cookie, leading to session hijacking and unauthorized account access. The flaw originates from using default cookie settings (`new Cookie(name, value)`) without invoking `cookie.setSecure(true)`. Key risks include:\r\n\r\n- **Session Exposure:** Attackers can read session identifiers in transit.\r\n- **Account Takeover:** Stolen cookies allow impersonation of legitimate users.\r\n- **Cross-Site Scripting Amplification:** Exploit of existing scripting flaws becomes easier if cookies lack transport protection.",
                    "howToPrevent": "1. Always set the **Secure** attribute on cookies carrying sensitive data:\r\n   ```java\r\n   Cookie cookie = new Cookie(\"name\", \"value\");\r\n   cookie.setSecure(true);\r\n   ```\r\n2. Enforce HTTPS across the entire application. Redirect all HTTP requests to HTTPS.\r\n3. Use **HttpOnly** and **SameSite** flags in combination to limit client-side script access and cross-site requests:\r\n   ```java\r\n   cookie.setHttpOnly(true);\r\n   cookie.setSecure(true);\r\n   cookie.setPath(\"/\");\r\n   cookie.setMaxAge(durationInSeconds);\r\n   response.addCookie(cookie);\r\n   ```\r\n4. Configure web framework or server to apply secure cookie defaults globally rather than per-instance.",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
                        "baseScore": "8.6"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "java",
                            "cookie"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "LOW",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast",
                "dataflow": [
                    {
                        "file": "src/main/java/org/owasp/webgoat/container/WebGoat.java",
                        "category": "BOOTSTRAP",
                        "ligne": 22,
                        "explication": "Application Spring Boot avec @ComponentScan incluant le package org.owasp.webgoat.lessons",
                        "variables": "ComponentScan"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "ENDPOINT_REGISTRATION",
                        "ligne": 53,
                        "explication": "Classe annotée @RestController implémentant AssignmentEndpoint, automatiquement détectée par Spring",
                        "variables": "JWTVotesEndpoint"
                    },
                    {
                        "file": "src/main/resources/lessons/jwt/js/jwt-voting.js",
                        "category": "UI_ACCESS",
                        "ligne": 7,
                        "explication": "Interface JavaScript appelant l'endpoint via AJAX JWT/votings/login avec paramètre user",
                        "variables": "user"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "SOURCE",
                        "ligne": 104,
                        "explication": "Paramètre HTTP user reçu via @RequestParam dans la méthode login",
                        "variables": "user"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "TOKEN_GENERATION",
                        "ligne": 109,
                        "explication": "Génération d'un JWT token contenant des données utilisateur sensibles",
                        "variables": "token"
                    },
                    {
                        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java",
                        "category": "SINK",
                        "ligne": 114,
                        "explication": "Création d'un cookie contenant le JWT sans flag Secure, transmissible sur HTTP",
                        "variables": "cookie"
                    },
                    {
                        "file": "src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java",
                        "category": "EXPLOITATION_PROOF",
                        "ligne": 99,
                        "explication": "Test unitaire vérifiant la création du cookie avec contenu sensible",
                        "variables": "access_token"
                    },
                    {
                        "file": "src/it/java/org/owasp/webgoat/integration/JWTLessonIntegrationTest.java",
                        "category": "INTEGRATION_PROOF",
                        "ligne": 136,
                        "explication": "Test d'intégration récupérant le cookie access_token depuis l'endpoint",
                        "variables": "access_token"
                    }
                ],
                "vulnerability_truth": {
                    "statut": "TP",
                    "explication": "Vrai positif confirmé - Le cookie access_token contenant un JWT avec des données sensibles (admin, user) est créé sans flag Secure à la ligne 114. L'endpoint /JWT/votings/login est pleinement intégré : (1) Accessible via interface JavaScript, (2) Testé dans les tests unitaires et d'intégration, (3) Cookie transmissible sur HTTP permettant l'interception du JWT par un attaquant réseau. Pas de code mort - la vulnérabilité est exploitable en production."
                }
            }
        },
        "vulnerability": "sast"
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "9a38a5aa-1366-4828-85e1-6ccfd450cf89",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 23,
                                "content": "    "
                            },
                            {
                                "line": 24,
                                "content": "    if (tokenManager.validateTokenFormat(processedToken)) {"
                            },
                            {
                                "line": 25,
                                "content": "      Cookie cookie = new Cookie(\"access_token\", userToken);"
                            },
                            {
                                "line": 26,
                                "content": "      cookieService.applyCookieDefaults(cookie);"
                            },
                            {
                                "line": 27,
                                "content": "      response.addCookie(cookie);"
                            }
                        ],
                        "id": "074b27c0-d263-4f31-92ea-5330d9c039c8",
                        "vulnerableStartLine": 25,
                        "vulnerableEndLine": 25,
                        "startLine": 23,
                        "endLine": 27,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "9a38a5aa-1366-4828-85e1-6ccfd450cf89",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:31:41.000Z",
                "updateAt": "2025-08-03T13:31:41.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/security/session/SessionManagementService.java",
                "vulnerableStartLine": 25,
                "vulnerableEndLine": 25,
                "vulnerability": {
                    "cwe": [
                        "CWE-319"
                    ],
                    "owaspTop10": [
                        "A03:2017 - Sensitive Data Exposure",
                        "A02:2021 - Cryptographic Failures"
                    ],
                    "cweArray": [
                        "CWE-319"
                    ],
                    "references": [
                        {
                            "id": "0c163946-05c4-4593-ae1f-68f151885676",
                            "name": "Java Servlet Cookie.setSecure(boolean) API Documentation",
                            "url": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)"
                        },
                        {
                            "id": "620f515c-24df-4432-adc1-5307053d20fe",
                            "name": "OWASP Secure Cookie Attribute",
                            "url": "https://owasp.org/www-community/controls/SecureCookieAttribute"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "cookie-issecure-false.java",
                            "content": "public class Bad {\n          public void bad1() {\n              // ruleid: cookie-issecure-false\n              Cookie cookie = new Cookie(\"name\", \"value\");\n          }\n   }\n\n public class Ok {\n          public void ok1() {\n             // ok: cookie-issecure-false\n             Cookie cookie = new Cookie(\"name\", \"value\");\n             cookie.setSecure(true);\n          }\n}\n"
                        }
                    ],
                    "id": "a216e0f1-7458-4388-a1c8-edbe7bd776af",
                    "name": "Insecure Cookie Without Secure Flag",
                    "shortDescription": "Cookie created without the Secure attribute may be sent over HTTP, exposing session data to network attackers.",
                    "description": "A session cookie is instantiated without setting its **Secure** attribute. Without this flag, browsers will transmit the cookie over unencrypted HTTP connections. An attacker positioned on the network path can intercept or steal the cookie, leading to session hijacking and unauthorized account access. The flaw originates from using default cookie settings (`new Cookie(name, value)`) without invoking `cookie.setSecure(true)`. Key risks include:\r\n\r\n- **Session Exposure:** Attackers can read session identifiers in transit.\r\n- **Account Takeover:** Stolen cookies allow impersonation of legitimate users.\r\n- **Cross-Site Scripting Amplification:** Exploit of existing scripting flaws becomes easier if cookies lack transport protection.",
                    "howToPrevent": "1. Always set the **Secure** attribute on cookies carrying sensitive data:\r\n   ```java\r\n   Cookie cookie = new Cookie(\"name\", \"value\");\r\n   cookie.setSecure(true);\r\n   ```\r\n2. Enforce HTTPS across the entire application. Redirect all HTTP requests to HTTPS.\r\n3. Use **HttpOnly** and **SameSite** flags in combination to limit client-side script access and cross-site requests:\r\n   ```java\r\n   cookie.setHttpOnly(true);\r\n   cookie.setSecure(true);\r\n   cookie.setPath(\"/\");\r\n   cookie.setMaxAge(durationInSeconds);\r\n   response.addCookie(cookie);\r\n   ```\r\n4. Configure web framework or server to apply secure cookie defaults globally rather than per-instance.",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L",
                        "baseScore": "8.6"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "audit"
                        ],
                        "technology": [
                            "java",
                            "cookie"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "LOW",
                        "impact": "LOW",
                        "likelihood": "LOW"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "SOURCE",
                "ligne": 41,
                "explication": "Paramètre HTTP username reçu via @RequestParam depuis l'endpoint /SecureAuth/authenticate",
                "variables": "username"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "TOKEN_GENERATION",
                "ligne": 47,
                "explication": "Génération d'un JWT token avec données utilisateur sensibles",
                "variables": "token"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/session/SessionManagementService.java",
                "category": "SECURITY_LAYER",
                "ligne": 22,
                "explication": "Création du cookie via CookieSecurityService avec application de sécurité automatique",
                "variables": "cookie"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/service/CookieSecurityService.java",
                "category": "SECURITY_APPLICATION",
                "ligne": 24,
                "explication": "Application automatique du flag Secure basé sur la configuration de sécurité",
                "variables": "cookie"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/config/SecurityConfiguration.java",
                "category": "SECURITY_CONFIG",
                "ligne": 15,
                "explication": "Configuration de sécurité activant shouldSecureCookies() via security.cookie.secure=true",
                "variables": "cookieSecureDefault"
            },
            {
                "file": "src/main/resources/application-webgoat.properties",
                "category": "CONFIG_SOURCE",
                "ligne": 12,
                "explication": "Propriété de configuration security.cookie.secure=true activant la sécurisation automatique",
                "variables": "security.cookie.secure"
            },
            {
                "file": "src/main/java/org/owasp/webgoat/lessons/security/controller/SecureAuthenticationController.java",
                "category": "SINK",
                "ligne": 51,
                "explication": "Cookie créé sans appel explicite setSecure() mais sécurisé par le service automatique",
                "variables": "cookie"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la ligne Cookie cookie = new Cookie('access_token', token) soit détectée comme vulnérable par le scanner, le cookie est automatiquement sécurisé par le CookieSecurityService. Le dataflow montre que applyCookieDefaults() est appelé dans SessionManagementService, qui applique setSecure(true) basé sur la configuration security.cookie.secure=true. La vulnérabilité apparente est neutralisée par cette couche de sécurité automatique."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "5d6d10b9-82f4-4d09-ba2e-1fe67e260c28",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 55,
                                "content": "        var decodedJWT = JWT.decode(token);"
                            },
                            {
                                "line": 56,
                                "content": "        var jku = decodedJWT.getHeaderClaim(\"jku\");"
                            },
                            {
                                "line": 57,
                                "content": "        var jwkProvider = new JwkProviderBuilder(new URL(jku.asString())).build();"
                            },
                            {
                                "line": 58,
                                "content": "        var jwk = jwkProvider.get(decodedJWT.getKeyId());"
                            },
                            {
                                "line": 59,
                                "content": "        var algorithm = Algorithm.RSA256((RSAPublicKey) jwk.getPublicKey());"
                            }
                        ],
                        "id": "e4fa559a-db9d-46a0-b4e1-8d917172e744",
                        "vulnerableStartLine": 57,
                        "vulnerableEndLine": 57,
                        "startLine": 55,
                        "endLine": 59,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "5d6d10b9-82f4-4d09-ba2e-1fe67e260c28",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:20.000Z",
                "updateAt": "2025-08-03T15:31:47.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java",
                "vulnerableStartLine": 57,
                "vulnerableEndLine": 57,
                "vulnerability": {
                    "cwe": [
                        "CWE-918"
                    ],
                    "owaspTop10": [
                        "A10:2021 - Server-Side Request Forgery (SSRF)"
                    ],
                    "cweArray": [
                        "CWE-918"
                    ],
                    "references": [],
                    "codeExamples": [
                        {
                            "filename": "tainted-url-host.go",
                            "content": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc handlerIndexFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Sprintf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Sprintf(\"https://%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Sprintf(\"http://%q\", proxy)\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOtherFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Printf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Fprintf(w, \"https://%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Fprintf(w, \"http://%q\", proxy)\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOkFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Printf(\"https://example.com/%v\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Sprintf(\"https://example.com/%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Fprintf(w, \"http://example.com%q\", proxy)\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc (s *server) handlerBadFmt(w http.ResponseWriter, r *http.Request) {\n\turls, ok := r.URL.Query()[\"url\"] // extract url from query params\n\n\tif !ok {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\tif len(urls) != 1 {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\turl := fmt.Sprintf(\"//%s/path\", urls[0])\n\n\t// ruleid: tainted-url-host\n\tresp, err := http.Get(url) // sink\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\n\t// ruleid: tainted-url-host\n\treq2, err := http.NewRequest(\"GET\", url, nil)\n\t_, err2 := client.Do(req2)\n\tif err2 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// ok: tainted-url-host\n\t_, err3 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\turl4 := fmt.Sprintf(\"ftps://%s/path/to/%s\", \"test\", r.URL.Path)\n\t// ok: tainted-url-host\n\t_, err4 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// Write out the hexdump of the bytes as plaintext.\n\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\tfmt.Fprint(w, hex.Dump(bytes))\n}\n\nfunc handlerIndexAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := \"https://\" + r.URL.Query().Get(\"proxy\") + \"/api\"\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://\" + proxy\n\t\t} else {\n\t\t\turl = \"http://\" + proxy\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOtherAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := \"https://\" + r.URL.Query().Get(\"proxy\") + \"/api\"\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://example.com/\" + proxy\n\t\t} else {\n\t\t\turl = \"http://example.com/api/test/\" + proxy\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOkAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(\"https://example.com/\"+r.URL.Query().Get(\"proxy\"), \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://example.com/\" + proxy\n\t\t} else {\n\t\t\turl = \"http://example.com\" + proxy\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc (s *server) handlerBadAdd(w http.ResponseWriter, r *http.Request) {\n\turls, ok := r.URL.Query()[\"url\"] // extract url from query params\n\n\tif !ok {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\tif len(urls) != 1 {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\turl := urls[0]\n\n\t// ruleid: tainted-url-host\n\tresp, err := http.Get(url) // sink\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\n\t// ruleid: tainted-url-host\n\treq2, err := http.NewRequest(\"GET\", r.URL.Path, nil)\n\t_, err2 := client.Do(req2)\n\tif err2 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// ok: tainted-url-host\n\t_, err3 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\turl4 := fmt.Sprintf(\"ftps://%s/path/to/%s\", \"test\", r.URL.Path)\n\t// ok: tainted-url-host\n\t_, err4 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// Write out the hexdump of the bytes as plaintext.\n\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\tfmt.Fprint(w, hex.Dump(bytes))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handlerIndex)\n\thttp.HandleFunc(\"/other\", handleOther)\n\thttp.HandleFunc(\"/ok\", handleOk)\n\thttp.HandleFunc(\"/bad\", handlerBad)\n\thttp.ListenAndServe(\":8888\", nil)\n}\n"
                        }
                    ],
                    "id": "a336610f-eeee-410e-8d9a-3db0b8212b4a",
                    "name": "Server-Side Request Forgery via Tainted URL Host",
                    "shortDescription": "User-controlled host in HTTP requests allows SSRF by making the server request arbitrary destinations.",
                    "description": "This vulnerability arises when the application constructs an outbound HTTP request using **unvalidated user input** as the host component. In the provided Go code, calls to `fmt.Sprintf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))` and similar patterns pass a user-supplied `proxy` parameter directly to `http.Client.Post`. An attacker can exploit this to perform **Server-Side Request Forgery (SSRF)**, causing the server to connect to internal or protected services, retrieve sensitive data, or interact with internal endpoints. The root cause is the absence of input validation or restrictions on the host, allowing arbitrary scheme, hostname, port, or IP. The risk includes unauthorized data disclosure, internal network scanning, or unintended interactions with internal APIs.",
                    "howToPrevent": "1. **Parse and validate the URL**\r\n   ```go\r\n   u, err := url.ParseRequestURI(userInput)\r\n   if err != nil {\r\n       return fmt.Errorf(\"invalid proxy URL\")\r\n   }\r\n   host := u.Hostname()\r\n   ```\r\n2. **Enforce an allowlist** of permitted hostnames or IP ranges:\r\n   ```go\r\n   allowed := map[string]bool{\"api.internal.local\": true}\r\n   if !allowed[host] {\r\n       return fmt.Errorf(\"proxy host not allowed\")\r\n   }\r\n   ```\r\n3. **Restrict the scheme** to HTTPS only:\r\n   ```go\r\n   if u.Scheme != \"https\" {\r\n       return fmt.Errorf(\"only https scheme is permitted\")\r\n   }\r\n   ```\r\n4. **Avoid `InsecureSkipVerify`** unless explicitly required. Validate TLS certificates to prevent downgrade or MITM.\r\n5. **Use separate fields** for hostname, path, and query rather than concatenating user data into a format string. Always reconstruct URLs with `url.URL` and its methods.",
                    "severity": "HIGH",
                    "language": "Go",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                        "baseScore": "7.5"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "go"
                        ],
                        "languages": [
                            "Go"
                        ],
                        "category": "security",
                        "confidence": "HIGH",
                        "impact": "MEDIUM",
                        "likelihood": "MEDIUM"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "/JWT/jku/delete",
                "category": "SOURCE",
                "ligne": 50,
                "explication": "Paramètre token reçu via @RequestParam dans l'endpoint REST",
                "variables": "token"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java",
                "category": "PROPAGATION",
                "ligne": 55,
                "explication": "Décodage du JWT sans validation préalable de la structure",
                "variables": "decodedJWT"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java",
                "category": "PROPAGATION",
                "ligne": 56,
                "explication": "Extraction du claim jku depuis l'header du JWT contrôlé par l'utilisateur",
                "variables": "jku"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java",
                "category": "SINK",
                "ligne": 57,
                "explication": "Construction d'URL non validée à partir du claim jku pour requête HTTP sortante vers JWK provider",
                "variables": "jku.asString()"
            },
            {
                "file": "java-dataset-webgoat/src/main/resources/lessons/jwt/html/JWT.html",
                "category": "INTEGRATION",
                "ligne": 323,
                "explication": "Interface utilisateur permettant l'exploitation via formulaire POST",
                "variables": "token parameter"
            },
            {
                "file": "java-dataset-webgoat/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpointTest.java",
                "category": "INTEGRATION",
                "ligne": 62,
                "explication": "Tests unitaires confirmant l'accessibilité et l'exploitabilité de l'endpoint",
                "variables": "token"
            },
            {
                "file": "java-dataset-webgoat/src/it/java/org/owasp/webgoat/integration/JWTLessonIntegrationTest.java",
                "category": "INTEGRATION",
                "ligne": 292,
                "explication": "Tests d'intégration end-to-end validant le scénario d'exploitation complet",
                "variables": "token"
            }
        ],
        "vulnerability_truth": {
            "statut": "TP",
            "explication": "Vraie vulnérabilité SSRF exploitable. L'endpoint /JWT/jku/delete accepte un token JWT où l'attaquant contrôle totalement le claim 'jku' dans l'header. Cette valeur est directement utilisée pour construire une URL sans validation, permettant de faire des requêtes HTTP vers des destinations arbitraires (SSRF). La vulnérabilité est accessible via l'interface web, validée par les tests, et pleinement exploitable car aucune validation ni liste blanche n'est implémentée sur l'URL de destination."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "7e5796f4-3ea5-4e03-aa80-62be500a754f",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 43,
                                "content": "        var decodedJWT = JWT.decode(token);"
                            },
                            {
                                "line": 44,
                                "content": "        var jku = decodedJWT.getHeaderClaim(\"jku\");"
                            },
                            {
                                "line": 45,
                                "content": "        var jwkProvider = new JwkProviderBuilder(new URL(jku.asString())).build();"
                            },
                            {
                                "line": 46,
                                "content": "        var jwk = jwkProvider.get(decodedJWT.getKeyId());"
                            },
                            {
                                "line": 47,
                                "content": "        var algorithm = Algorithm.RSA256((RSAPublicKey) jwk.getPublicKey());"
                            }
                        ],
                        "id": "e9a126b5-86cb-436a-b8e5-4a8e19f1ec58",
                        "vulnerableStartLine": 45,
                        "vulnerableEndLine": 45,
                        "startLine": 43,
                        "endLine": 47,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "7e5796f4-3ea5-4e03-aa80-62be500a754f",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:57:11.000Z",
                "updateAt": "2025-08-03T13:57:11.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTSecureHeaderEndpoint.java",
                "vulnerableStartLine": 45,
                "vulnerableEndLine": 45,
                "vulnerability": {
                    "cwe": [
                        "CWE-918"
                    ],
                    "owaspTop10": [
                        "A10:2021 - Server-Side Request Forgery (SSRF)"
                    ],
                    "cweArray": [
                        "CWE-918"
                    ],
                    "references": [],
                    "codeExamples": [
                        {
                            "filename": "tainted-url-host.go",
                            "content": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc handlerIndexFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Sprintf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Sprintf(\"https://%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Sprintf(\"http://%q\", proxy)\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOtherFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Printf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Fprintf(w, \"https://%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Fprintf(w, \"http://%q\", proxy)\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOkFmt(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := fmt.Printf(\"https://example.com/%v\", r.URL.Query().Get(\"proxy\"))\n\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = fmt.Sprintf(\"https://example.com/%s\", proxy)\n\t\t} else {\n\t\t\turl = fmt.Fprintf(w, \"http://example.com%q\", proxy)\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc (s *server) handlerBadFmt(w http.ResponseWriter, r *http.Request) {\n\turls, ok := r.URL.Query()[\"url\"] // extract url from query params\n\n\tif !ok {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\tif len(urls) != 1 {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\turl := fmt.Sprintf(\"//%s/path\", urls[0])\n\n\t// ruleid: tainted-url-host\n\tresp, err := http.Get(url) // sink\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\n\t// ruleid: tainted-url-host\n\treq2, err := http.NewRequest(\"GET\", url, nil)\n\t_, err2 := client.Do(req2)\n\tif err2 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// ok: tainted-url-host\n\t_, err3 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\turl4 := fmt.Sprintf(\"ftps://%s/path/to/%s\", \"test\", r.URL.Path)\n\t// ok: tainted-url-host\n\t_, err4 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// Write out the hexdump of the bytes as plaintext.\n\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\tfmt.Fprint(w, hex.Dump(bytes))\n}\n\nfunc handlerIndexAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := \"https://\" + r.URL.Query().Get(\"proxy\") + \"/api\"\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://\" + proxy\n\t\t} else {\n\t\t\turl = \"http://\" + proxy\n\t\t}\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOtherAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\turl := \"https://\" + r.URL.Query().Get(\"proxy\") + \"/api\"\n\n\t\t// ruleid: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://example.com/\" + proxy\n\t\t} else {\n\t\t\turl = \"http://example.com/api/test/\" + proxy\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc handlerOkAdd(w http.ResponseWriter, r *http.Request) {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\n\tif r.Method == \"POST\" && r.URL.Path == \"/api\" {\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(\"https://example.com/\"+r.URL.Query().Get(\"proxy\"), \"application/json\", r.Body)\n\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 200 {\n\t\t\tw.WriteHeader(500)\n\t\t\treturn\n\t\t}\n\n\t\tw.Write([]byte(fmt.Sprintf(\"{\\\"host\\\":\\\"%v\\\"}\", r.URL.Query().Get(\"proxy\"))))\n\t\treturn\n\t} else {\n\t\tproxy := r.URL.Query()[\"proxy\"]\n\t\tsecure := r.URL.Query()[\"secure\"]\n\n\t\turl := \"\"\n\t\tif secure {\n\t\t\turl = \"https://example.com/\" + proxy\n\t\t} else {\n\t\t\turl = \"http://example.com\" + proxy\n\t\t}\n\t\t// ok: tainted-url-host\n\t\tresp, err := client.Post(url, \"application/json\", r.Body)\n\t}\n}\n\nfunc (s *server) handlerBadAdd(w http.ResponseWriter, r *http.Request) {\n\turls, ok := r.URL.Query()[\"url\"] // extract url from query params\n\n\tif !ok {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\tif len(urls) != 1 {\n\t\thttp.Error(w, \"url missing\", 500)\n\t\treturn\n\t}\n\n\turl := urls[0]\n\n\t// ruleid: tainted-url-host\n\tresp, err := http.Get(url) // sink\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tclient := &http.Client{}\n\n\t// ruleid: tainted-url-host\n\treq2, err := http.NewRequest(\"GET\", r.URL.Path, nil)\n\t_, err2 := client.Do(req2)\n\tif err2 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// ok: tainted-url-host\n\t_, err3 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\turl4 := fmt.Sprintf(\"ftps://%s/path/to/%s\", \"test\", r.URL.Path)\n\t// ok: tainted-url-host\n\t_, err4 := http.Get(\"https://semgrep.dev\")\n\tif err3 != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\n\tbytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// Write out the hexdump of the bytes as plaintext.\n\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\tfmt.Fprint(w, hex.Dump(bytes))\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handlerIndex)\n\thttp.HandleFunc(\"/other\", handleOther)\n\thttp.HandleFunc(\"/ok\", handleOk)\n\thttp.HandleFunc(\"/bad\", handlerBad)\n\thttp.ListenAndServe(\":8888\", nil)\n}\n"
                        }
                    ],
                    "id": "a336610f-eeee-410e-8d9a-3db0b8212b4a",
                    "name": "Server-Side Request Forgery via Tainted URL Host",
                    "shortDescription": "User-controlled host in HTTP requests allows SSRF by making the server request arbitrary destinations.",
                    "description": "This vulnerability arises when the application constructs an outbound HTTP request using **unvalidated user input** as the host component. In the provided Go code, calls to `fmt.Sprintf(\"https://%v/api\", r.URL.Query().Get(\"proxy\"))` and similar patterns pass a user-supplied `proxy` parameter directly to `http.Client.Post`. An attacker can exploit this to perform **Server-Side Request Forgery (SSRF)**, causing the server to connect to internal or protected services, retrieve sensitive data, or interact with internal endpoints. The root cause is the absence of input validation or restrictions on the host, allowing arbitrary scheme, hostname, port, or IP. The risk includes unauthorized data disclosure, internal network scanning, or unintended interactions with internal APIs.",
                    "howToPrevent": "1. **Parse and validate the URL**\r\n   ```go\r\n   u, err := url.ParseRequestURI(userInput)\r\n   if err != nil {\r\n       return fmt.Errorf(\"invalid proxy URL\")\r\n   }\r\n   host := u.Hostname()\r\n   ```\r\n2. **Enforce an allowlist** of permitted hostnames or IP ranges:\r\n   ```go\r\n   allowed := map[string]bool{\"api.internal.local\": true}\r\n   if !allowed[host] {\r\n       return fmt.Errorf(\"proxy host not allowed\")\r\n   }\r\n   ```\r\n3. **Restrict the scheme** to HTTPS only:\r\n   ```go\r\n   if u.Scheme != \"https\" {\r\n       return fmt.Errorf(\"only https scheme is permitted\")\r\n   }\r\n   ```\r\n4. **Avoid `InsecureSkipVerify`** unless explicitly required. Validate TLS certificates to prevent downgrade or MITM.\r\n5. **Use separate fields** for hostname, path, and query rather than concatenating user data into a format string. Always reconstruct URLs with `url.URL` and its methods.",
                    "severity": "HIGH",
                    "language": "Go",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                        "baseScore": "7.5"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "go"
                        ],
                        "languages": [
                            "Go"
                        ],
                        "category": "security",
                        "confidence": "HIGH",
                        "impact": "MEDIUM",
                        "likelihood": "MEDIUM"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "/JWT/secure/validate",
                "category": "SOURCE",
                "ligne": 37,
                "explication": "Paramètre token reçu via @RequestParam dans l'endpoint REST sécurisé",
                "variables": "token"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTSecureHeaderEndpoint.java",
                "category": "PROPAGATION",
                "ligne": 42,
                "explication": "Décodage du JWT similaire au cas vulnérable",
                "variables": "decodedJWT"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTSecureHeaderEndpoint.java",
                "category": "PROPAGATION",
                "ligne": 43,
                "explication": "Extraction du claim jku depuis l'header du JWT",
                "variables": "jku"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/security/TokenContextManager.java",
                "category": "VALIDATION",
                "ligne": 35,
                "explication": "Validation subtile de l'URL via resolveKeyProviderUrl avec vérification des domaines autorisés",
                "variables": "jkuUrl"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/security/NetworkAccessValidator.java",
                "category": "SECURITY_CONTROL",
                "ligne": 20,
                "explication": "Validation contre liste blanche de domaines de confiance (AWS Cognito, Microsoft, Google, Auth0, Okta)",
                "variables": "urlString"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/security/JwtConfigurationResolver.java",
                "category": "CONFIGURATION",
                "ligne": 13,
                "explication": "Configuration activant la validation d'URL via webgoat.jwt.validate-urls=true",
                "variables": "validateUrls"
            },
            {
                "file": "java-dataset-webgoat/src/main/resources/application-webgoat.properties",
                "category": "CONFIGURATION",
                "ligne": 13,
                "explication": "Propriété de configuration activant la validation d'URL par défaut",
                "variables": "webgoat.jwt.validate-urls"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTSecureHeaderEndpoint.java",
                "category": "SINK",
                "ligne": 45,
                "explication": "Construction d'URL identique au cas vulnérable MAIS protégée par les validations en amont",
                "variables": "jku.asString()"
            },
            {
                "file": "java-dataset-webgoat/src/main/resources/lessons/jwt/html/JWTSecure.html",
                "category": "INTEGRATION",
                "ligne": 12,
                "explication": "Interface utilisateur permettant l'accès au endpoint sécurisé",
                "variables": "token parameter"
            },
            {
                "file": "java-dataset-webgoat/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTSecureHeaderEndpointTest.java",
                "category": "INTEGRATION",
                "ligne": 22,
                "explication": "Tests unitaires validant le rejet d'URLs malveillantes et l'acceptation d'URLs de confiance",
                "variables": "maliciousToken, trustedToken"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif malgré la présence de la ligne sink identique. Bien que le code contienne 'new URL(jku.asString())' sur la ligne 45 (identique au vrai positif), cette vulnérabilité apparente est neutralisée par un système de validation multi-couches subtil. Le dataflow passe par TokenContextManager.resolveKeyProviderUrl() qui applique NetworkAccessValidator.isUrlSafe() avec une liste blanche stricte de domaines de confiance. La configuration application-webgoat.properties active cette validation par défaut. Seules les URLs pointant vers des domaines légitimes (AWS Cognito, Microsoft, Google, Auth0, Okta) sont autorisées, bloquant toute tentative SSRF vers des cibles arbitraires. Les tests confirment que les URLs malveillantes sont rejetées."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "915605db-0281-40b3-a460-d47cff118ba0",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 77,
                                "content": "      Files.copy(is, destinationFile);"
                            },
                            {
                                "line": 78,
                                "content": "    }"
                            },
                            {
                                "line": 79,
                                "content": "    log.debug(\"File saved to {}\", new File(destinationDir, multipartFile.getOriginalFilename()));"
                            },
                            {
                                "line": 80,
                                "content": ""
                            },
                            {
                                "line": 81,
                                "content": "    return new ModelAndView("
                            }
                        ],
                        "id": "5ed5a766-8f0a-475c-a68a-076846d2d938",
                        "vulnerableStartLine": 79,
                        "vulnerableEndLine": 79,
                        "startLine": 77,
                        "endLine": 81,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "915605db-0281-40b3-a460-d47cff118ba0",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T13:00:21.000Z",
                "updateAt": "2025-08-03T15:57:16.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/FileServer.java",
                "vulnerableStartLine": 79,
                "vulnerableEndLine": 79,
                "vulnerability": {
                    "cwe": [
                        "CWE-23"
                    ],
                    "owaspTop10": [
                        "A01:2021 - Broken Access Control"
                    ],
                    "cweArray": [
                        "CWE-23"
                    ],
                    "references": [
                        {
                            "id": "9dfbf9a9-ba53-4bab-aded-249956921533",
                            "name": "OWASP Path Traversal",
                            "url": "https://owasp.org/www-community/attacks/Path_Traversal"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "tainted-file-path.java",
                            "content": "package org.sasanlabs.service.vulnerability.fileupload;\n\nimport static org.sasanlabs.service.vulnerability.fileupload.UnrestrictedFileUpload.CONTENT_DISPOSITION_STATIC_FILE_LOCATION;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.sasanlabs.internal.utility.FrameworkConstants;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.core.io.Resource;\n\n/**\n * Preflight is the request which is executed to download the uploaded file. This controller is made\n * specifically for content disposition based response. we could have created the similar endpoint\n * in {@code UnrestrictedFileUpload} but as framework appends the \"Vulnerability name\" hence created\n * a new endpoint.\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@RestController\npublic class PreflightController {\n    private UnrestrictedFileUpload unrestrictedFileUpload;\n\n    public PreflightController(UnrestrictedFileUpload unrestrictedFileUpload) {\n        this.unrestrictedFileUpload = unrestrictedFileUpload;\n    }\n\n    @RequestMapping(\n            CONTENT_DISPOSITION_STATIC_FILE_LOCATION + FrameworkConstants.SLASH + \"{fileName}\")\n    public ResponseEntity<byte[]> fetchFile(@PathVariable(\"fileName\") String fileName)\n            throws IOException {\n        InputStream inputStream =\n                // ruleid: tainted-file-path\n                new FileInputStream(\n                        unrestrictedFileUpload.getContentDispositionRoot().toFile()\n                                + FrameworkConstants.SLASH\n                                + fileName);\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment\");\n        return new ResponseEntity<byte[]>(\n                IOUtils.toByteArray(inputStream), httpHeaders, HttpStatus.OK);\n    }\n\n    public static void bad(@RequestParam String user)\n    {\n        Socket sock;\n        BufferedReader filenameReader = new BufferedReader(\n                new InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n        String filename = filenameReader.readLine();\n        // ruleid: tainted-file-path\n        BufferedReader fileReader = new BufferedReader(new FileReader(\"/home/\" + user + \"/\" + filename));\n        String fileLine = fileReader.readLine();\n        while(fileLine != null) {\n                sock.getOutputStream().write(fileLine.getBytes());\n                fileLine = fileReader.readLine();\n        }\n    }\n\n    public static void bad2(@RequestParam String filename)\n    {\n    \tApplicationContext appContext = \n    \t   new ClassPathXmlApplicationContext(new String[] {\"If-you-have-any.xml\"});\n\n        // ruleid: tainted-file-path\n    \tResource resource = appContext.getResource(\"classpath:com/\" + filename);\n                \n        try {\n           InputStream is = resource.getInputStream();\n           BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                \n           String line;\n           while ((line = br.readLine()) != null) {\n              System.out.println(line);\n           } \n           br.close();\n                \n        } catch(IOException e){\n           e.printStackTrace();\n        }\n    }\n\n    public static void ok(@RequestParam String filename)\n    {\n    \tApplicationContext appContext = \n    \t   new ClassPathXmlApplicationContext(new String[] {\"If-you-have-any.xml\"});\n\n        // ok: tainted-file-path\n    \tResource resource = \n           appContext.getResource(\"classpath:com/\" + org.apache.commons.io.FilenameUtils.getName(filename));\n                \n        try {\n           InputStream is = resource.getInputStream();\n           BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                \n           String line;\n           while ((line = br.readLine()) != null) {\n              System.out.println(line);\n           } \n           br.close();\n                \n        } catch(IOException e){\n           e.printStackTrace();\n        }\n    }\n\n    @Test\n    public void whenResourceAsFile_thenReadSuccessful(@RequestParam String filename) throws IOException {\n        // ruleid: tainted-file-path\n        File resource = new ClassPathResource(\"data/employees.dat\" + filename).getFile();\n        String employees = new String(Files.readAllBytes(resource.toPath()));\n        assertEquals(\"Joe Employee,Jan Employee,James T. Employee\", employees);\n    }\n}\n"
                        }
                    ],
                    "id": "e712810d-a994-4c38-b10b-c1d1f2edf77e",
                    "name": "File Path Traversal",
                    "shortDescription": "User input controls file path allowing traversal (e.g., '../') to access unintended files.",
                    "description": "**Path traversal** occurs when **user-controlled input** is incorporated directly into a file system path without validation or normalization. In the example, the `fileName` path variable is concatenated with a root directory and passed to `new FileInputStream(...)`. An attacker can include sequences like `../` to navigate outside the intended directory and read arbitrary files. This exposes sensitive data and can lead to a **confidentiality breach** of any file accessible to the application process.\r\n\r\n**Root cause**: Direct use of unvalidated user input in file system paths.\r\n\r\n**Risk**: Attackers can retrieve configuration files, source code, credentials, or other sensitive data by traversing directories.",
                    "howToPrevent": "- **Normalize and validate** the file name before use. Use APIs that remove path components, for example:\r\n  ```java\r\n  String safeName = FilenameUtils.getName(fileName);\r\n  File base = unrestrictedFileUpload.getContentDispositionRoot().toFile();\r\n  File target = new File(base, safeName).getCanonicalFile();\r\n  if (!target.getPath().startsWith(base.getCanonicalPath())) {\r\n      throw new SecurityException(\"Invalid file path\");\r\n  }\r\n  try (InputStream in = new FileInputStream(target)) {\r\n      // proceed with reading\r\n  }\r\n  ```\r\n- **Enforce a whitelist** of allowed file names or extensions.\r\n- **Use framework utilities** for file upload/download that handle path normalization and sandboxing.\r\n- **Reject or sanitize** any input containing path separators (`'/'`, `'\\\\'`) or traversal sequences (`'..'`).",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                        "baseScore": "7.5"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java",
                            "spring"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "HIGH",
                        "impact": "HIGH",
                        "likelihood": "MEDIUM"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "/fileupload",
                "category": "SOURCE",
                "ligne": 66,
                "explication": "Réception du fichier uploadé via @RequestParam MultipartFile dans l'endpoint POST",
                "variables": "multipartFile"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/FileServer.java",
                "category": "PROPAGATION",
                "ligne": 67,
                "explication": "Extraction du nom de fichier original contrôlé par l'utilisateur",
                "variables": "multipartFile.getOriginalFilename()"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/FileServer.java",
                "category": "SINK_DETECTED_BUT_NOT_DANGEROUS",
                "ligne": 79,
                "explication": "Ligne détectée par le scanner - construction de File avec nom non validé MAIS utilisé uniquement pour logging",
                "variables": "multipartFile.getOriginalFilename()"
            },
            {
                "file": "java-dataset-webgoat/src/main/resources/webwolf/templates/files.html",
                "category": "INTEGRATION",
                "ligne": 28,
                "explication": "Interface utilisateur permettant l'upload de fichier via formulaire POST multipart",
                "variables": "file input"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif. Bien que multipartFile.getOriginalFilename() puisse contenir des séquences de path traversal comme '../', la ligne 79 détectée par le scanner ne fait qu'utiliser cette valeur dans un appel de logging (log.debug). Aucune opération de fichier dangereuse n'est effectuée sur cette ligne spécifique. Le logging d'un nom de fichier non validé ne constitue pas une vulnérabilité de sécurité exploitable, juste une exposition d'information dans les logs. Note: Il existe une vraie vulnérabilité de path traversal à la ligne 76 avec Path.resolve(), mais ce n'est pas ce que le scanner a détecté."
        }
    },
    {
        "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
        "vulnerabilityId": "b294d697-2959-4f88-9662-c7bbfdcd5c21",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 49,
                                "content": "    }"
                            },
                            {
                                "line": 50,
                                "content": "    "
                            },
                            {
                                "line": 51,
                                "content": "    log.debug(\"File saved to {}\", new File(destinationDir, multipartFile.getOriginalFilename()));"
                            },
                            {
                                "line": 52,
                                "content": ""
                            },
                            {
                                "line": 53,
                                "content": "    return new ModelAndView("
                            }
                        ],
                        "id": "27e72d5b-f389-4846-8893-3ec10f598b68",
                        "vulnerableStartLine": 51,
                        "vulnerableEndLine": 51,
                        "startLine": 49,
                        "endLine": 53,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "b294d697-2959-4f88-9662-c7bbfdcd5c21",
                "projectId": "a90bd278-be41-485f-9b89-172152ce53ed",
                "createdAt": "2025-08-03T14:17:29.000Z",
                "updateAt": "2025-08-03T14:17:29.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "HIGH",
                "currentPriority": "urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/AdvancedFileProcessor.java",
                "vulnerableStartLine": 51,
                "vulnerableEndLine": 51,
                "vulnerability": {
                    "cwe": [
                        "CWE-23"
                    ],
                    "owaspTop10": [
                        "A01:2021 - Broken Access Control"
                    ],
                    "cweArray": [
                        "CWE-23"
                    ],
                    "references": [
                        {
                            "id": "9dfbf9a9-ba53-4bab-aded-249956921533",
                            "name": "OWASP Path Traversal",
                            "url": "https://owasp.org/www-community/attacks/Path_Traversal"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "tainted-file-path.java",
                            "content": "package org.sasanlabs.service.vulnerability.fileupload;\n\nimport static org.sasanlabs.service.vulnerability.fileupload.UnrestrictedFileUpload.CONTENT_DISPOSITION_STATIC_FILE_LOCATION;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.sasanlabs.internal.utility.FrameworkConstants;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.core.io.Resource;\n\n/**\n * Preflight is the request which is executed to download the uploaded file. This controller is made\n * specifically for content disposition based response. we could have created the similar endpoint\n * in {@code UnrestrictedFileUpload} but as framework appends the \"Vulnerability name\" hence created\n * a new endpoint.\n *\n * @author KSASAN preetkaran20@gmail.com\n */\n@RestController\npublic class PreflightController {\n    private UnrestrictedFileUpload unrestrictedFileUpload;\n\n    public PreflightController(UnrestrictedFileUpload unrestrictedFileUpload) {\n        this.unrestrictedFileUpload = unrestrictedFileUpload;\n    }\n\n    @RequestMapping(\n            CONTENT_DISPOSITION_STATIC_FILE_LOCATION + FrameworkConstants.SLASH + \"{fileName}\")\n    public ResponseEntity<byte[]> fetchFile(@PathVariable(\"fileName\") String fileName)\n            throws IOException {\n        InputStream inputStream =\n                // ruleid: tainted-file-path\n                new FileInputStream(\n                        unrestrictedFileUpload.getContentDispositionRoot().toFile()\n                                + FrameworkConstants.SLASH\n                                + fileName);\n        HttpHeaders httpHeaders = new HttpHeaders();\n        httpHeaders.add(HttpHeaders.CONTENT_DISPOSITION, \"attachment\");\n        return new ResponseEntity<byte[]>(\n                IOUtils.toByteArray(inputStream), httpHeaders, HttpStatus.OK);\n    }\n\n    public static void bad(@RequestParam String user)\n    {\n        Socket sock;\n        BufferedReader filenameReader = new BufferedReader(\n                new InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n        String filename = filenameReader.readLine();\n        // ruleid: tainted-file-path\n        BufferedReader fileReader = new BufferedReader(new FileReader(\"/home/\" + user + \"/\" + filename));\n        String fileLine = fileReader.readLine();\n        while(fileLine != null) {\n                sock.getOutputStream().write(fileLine.getBytes());\n                fileLine = fileReader.readLine();\n        }\n    }\n\n    public static void bad2(@RequestParam String filename)\n    {\n    \tApplicationContext appContext = \n    \t   new ClassPathXmlApplicationContext(new String[] {\"If-you-have-any.xml\"});\n\n        // ruleid: tainted-file-path\n    \tResource resource = appContext.getResource(\"classpath:com/\" + filename);\n                \n        try {\n           InputStream is = resource.getInputStream();\n           BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                \n           String line;\n           while ((line = br.readLine()) != null) {\n              System.out.println(line);\n           } \n           br.close();\n                \n        } catch(IOException e){\n           e.printStackTrace();\n        }\n    }\n\n    public static void ok(@RequestParam String filename)\n    {\n    \tApplicationContext appContext = \n    \t   new ClassPathXmlApplicationContext(new String[] {\"If-you-have-any.xml\"});\n\n        // ok: tainted-file-path\n    \tResource resource = \n           appContext.getResource(\"classpath:com/\" + org.apache.commons.io.FilenameUtils.getName(filename));\n                \n        try {\n           InputStream is = resource.getInputStream();\n           BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                \n           String line;\n           while ((line = br.readLine()) != null) {\n              System.out.println(line);\n           } \n           br.close();\n                \n        } catch(IOException e){\n           e.printStackTrace();\n        }\n    }\n\n    @Test\n    public void whenResourceAsFile_thenReadSuccessful(@RequestParam String filename) throws IOException {\n        // ruleid: tainted-file-path\n        File resource = new ClassPathResource(\"data/employees.dat\" + filename).getFile();\n        String employees = new String(Files.readAllBytes(resource.toPath()));\n        assertEquals(\"Joe Employee,Jan Employee,James T. Employee\", employees);\n    }\n}\n"
                        }
                    ],
                    "id": "e712810d-a994-4c38-b10b-c1d1f2edf77e",
                    "name": "File Path Traversal",
                    "shortDescription": "User input controls file path allowing traversal (e.g., '../') to access unintended files.",
                    "description": "**Path traversal** occurs when **user-controlled input** is incorporated directly into a file system path without validation or normalization. In the example, the `fileName` path variable is concatenated with a root directory and passed to `new FileInputStream(...)`. An attacker can include sequences like `../` to navigate outside the intended directory and read arbitrary files. This exposes sensitive data and can lead to a **confidentiality breach** of any file accessible to the application process.\r\n\r\n**Root cause**: Direct use of unvalidated user input in file system paths.\r\n\r\n**Risk**: Attackers can retrieve configuration files, source code, credentials, or other sensitive data by traversing directories.",
                    "howToPrevent": "- **Normalize and validate** the file name before use. Use APIs that remove path components, for example:\r\n  ```java\r\n  String safeName = FilenameUtils.getName(fileName);\r\n  File base = unrestrictedFileUpload.getContentDispositionRoot().toFile();\r\n  File target = new File(base, safeName).getCanonicalFile();\r\n  if (!target.getPath().startsWith(base.getCanonicalPath())) {\r\n      throw new SecurityException(\"Invalid file path\");\r\n  }\r\n  try (InputStream in = new FileInputStream(target)) {\r\n      // proceed with reading\r\n  }\r\n  ```\r\n- **Enforce a whitelist** of allowed file names or extensions.\r\n- **Use framework utilities** for file upload/download that handle path normalization and sandboxing.\r\n- **Reject or sanitize** any input containing path separators (`'/'`, `'\\\\'`) or traversal sequences (`'..'`).",
                    "severity": "HIGH",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                        "baseScore": "7.5"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java",
                            "spring"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "HIGH",
                        "impact": "HIGH",
                        "likelihood": "MEDIUM"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "/advanced-upload",
                "category": "SOURCE",
                "ligne": 30,
                "explication": "Réception du fichier uploadé via @RequestParam MultipartFile dans l'endpoint POST avancé",
                "variables": "multipartFile"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/AdvancedFileProcessor.java",
                "category": "PROPAGATION",
                "ligne": 43,
                "explication": "Passage du nom de fichier au processeur de métadonnées pour traitement avancé",
                "variables": "multipartFile.getOriginalFilename()"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/services/DocumentMetadataProcessor.java",
                "category": "PROPAGATION",
                "ligne": 9,
                "explication": "Transmission du nom de fichier à l'analyseur de système de fichiers",
                "variables": "fileName"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/services/FileSystemAnalyzer.java",
                "category": "PROPAGATION",
                "ligne": 13,
                "explication": "Résolution du chemin via DocumentPathResolver avec nom de fichier non validé",
                "variables": "fileName"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/services/DocumentPathResolver.java",
                "category": "WEAK_VALIDATION",
                "ligne": 10,
                "explication": "Validation défaillante qui ne bloque pas les séquences de path traversal '../'",
                "variables": "fileName"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/services/PathValidator.java",
                "category": "INSUFFICIENT_SANITIZATION",
                "ligne": 16,
                "explication": "Sanitisation insuffisante - remplace seulement les backslashes mais ignore les '../'",
                "variables": "cleaned"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/services/FileSystemAnalyzer.java",
                "category": "SINK",
                "ligne": 20,
                "explication": "Construction de File avec chemin traversé permettant accès à des fichiers arbitraires du système",
                "variables": "fullPath"
            },
            {
                "file": "java-dataset-webgoat/src/main/java/org/owasp/webgoat/webwolf/AdvancedFileProcessor.java",
                "category": "SINK_DETECTED_IDENTICAL",
                "ligne": 49,
                "explication": "Ligne sink identique au FP - log avec nom de fichier non validé MAIS rendue dangereuse par le dataflow précédent",
                "variables": "multipartFile.getOriginalFilename()"
            },
            {
                "file": "java-dataset-webgoat/src/main/resources/webwolf/templates/advanced-upload.html",
                "category": "INTEGRATION",
                "ligne": 22,
                "explication": "Interface utilisateur permettant l'upload via formulaire POST avec traitement avancé",
                "variables": "file input"
            },
            {
                "file": "java-dataset-webgoat/src/test/java/org/owasp/webgoat/webwolf/AdvancedFileProcessorTest.java",
                "category": "INTEGRATION",
                "ligne": 31,
                "explication": "Tests confirmant l'accessibilité du endpoint et la possibilité d'upload avec noms traversés",
                "variables": "malicious filename"
            }
        ],
        "vulnerability_truth": {
            "statut": "TP",
            "explication": "Vrai positif malgré la ligne sink identique au FP. Bien que la ligne 49 soit techniquement identique (log.debug avec new File()), elle devient exploitable dans ce contexte car le dataflow passe par un système de traitement de métadonnées complexe. Le nom de fichier multipartFile.getOriginalFilename() traverse plusieurs couches (DocumentMetadataProcessor → FileSystemAnalyzer → DocumentPathResolver → PathValidator) où la validation est insuffisante. Le PathValidator ne bloque que les backslashes mais ignore les '../'. Cela permet à un attaquant d'utiliser des noms comme '../../../etc/passwd.pdf' qui sont traités par FileSystemAnalyzer.performAnalysis() à la ligne 20, où un new File(fullPath) avec le chemin traversé donne accès à des fichiers système arbitraires via Files.readAllLines(). La vulnérabilité est accessible via l'interface web et confirmée par les tests d'intégration."
        }
    }
]