[
    {
        "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
        "vulnerabilityId": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
        "sast": {
            "base": {
                "codeSnippets": [
                    {
                        "code": [
                            {
                                "line": 63,
                                "content": "      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);"
                            },
                            {
                                "line": 64,
                                "content": "      SqlInjectionLesson8.log(connection, queryInjection);"
                            },
                            {
                                "line": 65,
                                "content": "      statement.execute(queryInjection);"
                            },
                            {
                                "line": 66,
                                "content": "      // check new sum of salaries other employees and new salaries of John"
                            },
                            {
                                "line": 67,
                                "content": "      int newJohnSalary = this.getJohnSalary(connection);"
                            }
                        ],
                        "id": "899ee690-ee13-42f0-aaea-7dd84746ef5f",
                        "vulnerableStartLine": 65,
                        "vulnerableEndLine": 65,
                        "startLine": 63,
                        "endLine": 67,
                        "language": "Java",
                        "fixAnalysis": "",
                        "fixAnalysisDescription": ""
                    }
                ],
                "id": "01b6339d-90c2-435c-ae8e-b64bf1acc39d",
                "projectId": "2483dd9b-254e-424b-a050-7397848335f3",
                "createdAt": "2025-07-31T11:45:32.000Z",
                "updateAt": "2025-07-31T11:45:32.000Z",
                "timeToFix": "",
                "currentState": "to_verify",
                "currentSeverity": "CRITICAL",
                "currentPriority": "critical_urgent",
                "contextualExplanation": "",
                "language": "Java",
                "path": "WebGoat-main/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "vulnerableStartLine": 65,
                "vulnerableEndLine": 65,
                "vulnerability": {
                    "cwe": [
                        "CWE-89"
                    ],
                    "owaspTop10": [
                        "A01:2017 - Injection",
                        "A03:2021 - Injection"
                    ],
                    "cweArray": [
                        "CWE-89"
                    ],
                    "references": [
                        {
                            "id": "335c0c98-7673-4706-b8c7-55a87065db50",
                            "name": "Find Security Bugs: SQL_INJECTION",
                            "url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION"
                        },
                        {
                            "id": "79e15a83-0fd8-404a-81b8-386983d87642",
                            "name": "Oracle JDBC PreparedStatement Tutorial",
                            "url": "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps"
                        },
                        {
                            "id": "8b451295-df89-4f29-b667-8287ad8c2181",
                            "name": "SANS Guide: Fixing SQL Injection in Java",
                            "url": "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
                        },
                        {
                            "id": "9b2e1b52-bdca-4ae4-8af0-2b41040bf447",
                            "name": "OWASP SQL Injection Prevention Cheat Sheet",
                            "url": "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                        }
                    ],
                    "codeExamples": [
                        {
                            "filename": "formatted-sql-string.java",
                            "content": "// cf. https://www.baeldung.com/sql-injection\n\npackage sql.injection;\n\nimport com.biz.org.AccountDTO;\nimport com.biz.org.DB;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport javax.persistence.criteria.CriteriaBuilder;\n\npublic class SqlExample {\n    public void staticQuery() throws SQLException {\n        Connection c = DB.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM happy_messages\");\n    }\n\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n\n    public void findAccountsById(String id, String field) throws SQLException {\n        String sql = \"SELECT \";\n        sql += field;\n        sql += \" FROM accounts WHERE id = '\";\n        sql += id;\n        sql += \"'\";\n        Connection c = DB.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().executeQuery(sql);\n    }\n}\n\npublic class SqlExample2 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(\"SELECT * FROM \" + tableName);\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = \"SELECT * \"\n            + \"FROM accounts WHERE id = '\"\n            + id\n            + \"'\";\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = \"from Account where id = '\" + id + \"'\";\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid:formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n}\n\npublic class SQLExample3 {\n    public void getAllFields(String tableName) throws SQLException {\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(String.format(\"SELECT * FROM %s\", tableName));\n    }\n\n    public void findAccountsById(String id) throws SQLException {\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ruleid:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n    public List<AccountDTO> findAccountsById(String id) {\n        String jql = String.format(\"from Account where id = '%s'\", id);\n        EntityManager em = emfactory.createEntityManager();\n        // ruleid: formatted-sql-string\n        TypedQuery<Account> q = em.createQuery(jql, Account.class);\n        return q.getResultList()\n        .stream()\n        .map(this::toAccountDTO)\n        .collect(Collectors.toList());\n    }\n\n    public void findAccountsByIdOk() throws SQLException {\n        String id = \"const\";\n        String sql = String.format(\"SELECT * FROM accounts WHERE id = '%s'\", id);\n        Connection c = db.getConnection();\n        // ok:formatted-sql-string\n        ResultSet rs = c.createStatement().execute(sql);\n    }\n\n}\n\npublic class tableConcatStatements {\n    public void tableConcat() {\n        // ok:formatted-sql-string\n        stmt.execute(\"DROP TABLE \" + tableName);\n        stmt.execute(String.format(\"CREATE TABLE %s\", tableName));\n    }\n}\n\n// This whole operation has nothing to do with SQL\npublic class FalsePositiveCase {\n    private ApiClient apiClient; // imagine an ApiClient class that contains a method named execute\n\n    public void test(String parameter) throws ApiException {\n        com.squareup.okhttp.Call call = constructHttpCall(parameter); // Create OKHttp call using parameter from outside\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        // ok: formatted-sql-string\n        apiClient.execute(call);\n        apiClient.run(call); // proof that 'execute' name is causing the false-positive\n    }\n\n    public List<Student> addWhere(String name, CriteriaQuery Query)\n    {\n        EntityManager em = emfactory.createEntityManager();\n    \tCriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();\n\t\t// ok: formatted-sql-string\n        List<Student> students = em.createQuery(Query.where(criteriaBuilder.equal(studentRoot.get(\"name\"), name ))).getResultList();\n        return students;\n    }\n}\n"
                        }
                    ],
                    "id": "44c428aa-403c-4872-9cac-c71d0ca07f53",
                    "name": "SQL Injection via Unparameterized Queries",
                    "shortDescription": "String concatenation in SQL statements allows injection of malicious input, leading to unauthorized data access or modification.",
                    "description": "**Unparameterized SQL queries** constructed via string concatenation allow attacker-controlled input (for example, `id`, `tableName`, or `field`) to modify the intended SQL command. In the provided code, calls to `createStatement().executeQuery(...)` build SQL strings by appending user input directly, bypassing input validation and escaping. This can lead to injection of malicious SQL fragments, enabling unauthorized **data retrieval**, **modification**, or **deletion**, and potentially execution of additional statements. The vulnerability risks exposure of sensitive data, data corruption, privilege escalation, and denial of service.",
                    "howToPrevent": "Use **parameterized queries** via `PreparedStatement`:\r\n\r\n- Obtain a `PreparedStatement` with `connection.prepareStatement(sql)` and use `?` placeholders for all external inputs.\r\n- Bind values using methods such as `setString()`, `setInt()`, etc., which enforce correct escaping and typing.\r\n- Validate and whitelist any dynamic identifiers (for example, table or column names) before including them in SQL.\r\n- Avoid building SQL by concatenating user input. If dynamic SQL is unavoidable, strictly restrict allowed values to a predefined whitelist.",
                    "severity": "CRITICAL",
                    "language": "Java",
                    "vulnerabilityType": "sast",
                    "cvss3": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                        "baseScore": "10.0"
                    },
                    "_cvss3": "cvss3",
                    "sourceMetadata": {
                        "subcategory": [
                            "vuln"
                        ],
                        "technology": [
                            "java"
                        ],
                        "languages": [
                            "Java"
                        ],
                        "category": "security",
                        "confidence": "MEDIUM",
                        "impact": "MEDIUM",
                        "likelihood": "HIGH"
                    },
                    "_sourceMetadata": "sourceMetadata"
                },
                "historyItems": {
                    "items": []
                },
                "vulnerabilityType": "sast"
            }
        },
        "vulnerability": "sast",
        "dataflow": [
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/resources/lessons/sqlinjection/html/SqlInjection.html",
                "category": "SOURCE",
                "ligne": 252,
                "explication": "Input utilisateur via formulaire HTML - champ name",
                "variables": "name"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/resources/lessons/sqlinjection/html/SqlInjection.html", 
                "category": "SOURCE",
                "ligne": 255,
                "explication": "Input utilisateur via formulaire HTML - champ auth_tan",
                "variables": "auth_tan"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "category": "ETAPE",
                "ligne": 44,
                "explication": "Réception des paramètres HTTP via @RequestParam sans validation",
                "variables": "name, auth_tan"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "category": "ETAPE", 
                "ligne": 45,
                "explication": "Passage des paramètres non validés à la méthode vulnérable",
                "variables": "name, auth_tan"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "category": "ETAPE",
                "ligne": 50,
                "explication": "Construction de requête SQL par concaténation directe des paramètres utilisateur",
                "variables": "queryInjection"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java",
                "category": "SINK",
                "ligne": 65,
                "explication": "Exécution de la requête SQL non paramétrisée contenant les données utilisateur",
                "variables": "queryInjection"
            }
        ],
        "vulnerability_truth": {
            "statut": "TP",
            "explication": "Vrai positif - Injection SQL via concaténation directe de paramètres utilisateur non validés dans une requête SQL. Les données arrivent via un formulaire HTML accessible publiquement, sont passées directement dans la construction de la requête SQL sans aucune validation ni échappement, puis exécutées via statement.execute(). Cette vulnérabilité permet à un attaquant d'injecter du code SQL arbitraire."
        }
    },
    {
        "dataflow": [
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/resources/lessons/sqlinjection/html/AdvancedEmployeeSearch.html",
                "category": "SOURCE",
                "ligne": 13,
                "explication": "Input utilisateur via formulaire HTML - champ criteria",
                "variables": "criteria"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/resources/lessons/sqlinjection/html/AdvancedEmployeeSearch.html",
                "category": "SOURCE", 
                "ligne": 16,
                "explication": "Input utilisateur via formulaire HTML - champ department",
                "variables": "department"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/EmployeeSearchController.java",
                "category": "ETAPE",
                "ligne": 25,
                "explication": "Réception des paramètres HTTP via @RequestParam",
                "variables": "criteria, department"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/EmployeeSearchController.java",
                "category": "ETAPE",
                "ligne": 26,
                "explication": "Création d'un objet request avec les paramètres",
                "variables": "request"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/EmployeeSearchService.java",
                "category": "ETAPE",
                "ligne": 21,
                "explication": "Validation stricte des entrées utilisateur avec suppression des caractères dangereux",
                "variables": "validationResult"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/InputValidator.java",
                "category": "ETAPE",
                "ligne": 30,
                "explication": "Sanitisation des données - suppression des caractères SQL dangereux et échappement des apostrophes",
                "variables": "sanitized"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SearchParameters.java",
                "category": "ETAPE",
                "ligne": 7,
                "explication": "Stockage des paramètres validés et nettoyés",
                "variables": "cleanCriteria, cleanDepartment"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/DatabaseQueryBuilder.java",
                "category": "ETAPE",
                "ligne": 11,
                "explication": "Construction de requête SQL par concaténation avec données déjà sanitisées",
                "variables": "searchQuery"
            },
            {
                "file": "/Users/julienzammit/Documents/GitHub/java-dataset-webgoat/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/QueryProcessor.java",
                "category": "SINK",
                "ligne": 27,
                "explication": "Exécution de la requête SQL construite avec des données validées et échappées",
                "variables": "searchQuery"
            }
        ],
        "vulnerability_truth": {
            "statut": "FP",
            "explication": "Faux positif - Bien que la requête SQL soit construite par concaténation de chaînes (déclenchant le scanner SAST), les données utilisateur passent par une validation rigoureuse dans InputValidator qui supprime tous les caractères SQL dangereux via regex, échappe les apostrophes, et valide strictement le format et la longueur. Cette sanitisation en amont rend l'injection SQL impossible malgré la construction de requête par concaténation."
        }
    }
]